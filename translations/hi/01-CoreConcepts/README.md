<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "88b863a69b4f18b15e82da358ffd3489",
  "translation_date": "2025-08-21T12:47:17+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "hi"
}
-->
# MCP कोर अवधारणाएँ: एआई इंटीग्रेशन के लिए मॉडल कॉन्टेक्स्ट प्रोटोकॉल में महारत हासिल करना

[![MCP कोर अवधारणाएँ](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.hi.png)](https://youtu.be/earDzWGtE84)

_(ऊपर दी गई छवि पर क्लिक करें इस पाठ का वीडियो देखने के लिए)_

[Model Context Protocol (MCP)](https://github.com/modelcontextprotocol) एक शक्तिशाली, मानकीकृत फ्रेमवर्क है जो बड़े भाषा मॉडल (LLMs) और बाहरी टूल्स, एप्लिकेशन, और डेटा स्रोतों के बीच संचार को अनुकूलित करता है।  
यह गाइड आपको MCP की कोर अवधारणाओं के माध्यम से ले जाएगा। आप इसके क्लाइंट-सर्वर आर्किटेक्चर, आवश्यक घटकों, संचार तंत्र, और कार्यान्वयन के सर्वोत्तम अभ्यासों के बारे में जानेंगे।

- **स्पष्ट उपयोगकर्ता सहमति**: सभी डेटा एक्सेस और ऑपरेशन्स को निष्पादित करने से पहले उपयोगकर्ता की स्पष्ट स्वीकृति की आवश्यकता होती है। उपयोगकर्ताओं को यह स्पष्ट रूप से समझना चाहिए कि कौन सा डेटा एक्सेस किया जाएगा और कौन सी क्रियाएँ की जाएंगी, साथ ही अनुमतियों और प्राधिकरणों पर विस्तृत नियंत्रण होना चाहिए।

- **डेटा गोपनीयता सुरक्षा**: उपयोगकर्ता डेटा केवल स्पष्ट सहमति के साथ उजागर किया जाता है और पूरे इंटरैक्शन जीवनचक्र में मजबूत एक्सेस नियंत्रण द्वारा संरक्षित किया जाना चाहिए। कार्यान्वयन को अनधिकृत डेटा ट्रांसमिशन को रोकना चाहिए और सख्त गोपनीयता सीमाएँ बनाए रखनी चाहिए।

- **टूल निष्पादन सुरक्षा**: प्रत्येक टूल को चलाने के लिए उपयोगकर्ता की स्पष्ट सहमति की आवश्यकता होती है, जिसमें टूल की कार्यक्षमता, पैरामीटर, और संभावित प्रभाव की स्पष्ट समझ हो। अनपेक्षित, असुरक्षित, या दुर्भावनापूर्ण टूल निष्पादन को रोकने के लिए मजबूत सुरक्षा सीमाएँ होनी चाहिए।

- **ट्रांसपोर्ट लेयर सुरक्षा**: सभी संचार चैनलों को उपयुक्त एन्क्रिप्शन और प्रमाणीकरण तंत्र का उपयोग करना चाहिए। रिमोट कनेक्शन को सुरक्षित ट्रांसपोर्ट प्रोटोकॉल और उचित क्रेडेंशियल प्रबंधन लागू करना चाहिए।

#### कार्यान्वयन दिशानिर्देश:

- **अनुमति प्रबंधन**: उपयोगकर्ताओं को यह नियंत्रित करने की अनुमति देने के लिए विस्तृत अनुमति प्रणाली लागू करें कि कौन से सर्वर, टूल्स, और संसाधन सुलभ हैं।  
- **प्रमाणीकरण और प्राधिकरण**: सुरक्षित प्रमाणीकरण विधियों (OAuth, API कुंजियाँ) का उपयोग करें, साथ ही उचित टोकन प्रबंधन और समाप्ति।  
- **इनपुट मान्यता**: इंजेक्शन हमलों को रोकने के लिए परिभाषित स्कीमाओं के अनुसार सभी पैरामीटर और डेटा इनपुट को मान्य करें।  
- **ऑडिट लॉगिंग**: सुरक्षा निगरानी और अनुपालन के लिए सभी ऑपरेशन्स का व्यापक लॉग बनाए रखें।  

## अवलोकन

यह पाठ मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP) इकोसिस्टम की मौलिक वास्तुकला और घटकों की खोज करता है। आप MCP इंटरैक्शन को शक्ति देने वाले क्लाइंट-सर्वर आर्किटेक्चर, प्रमुख घटकों, और संचार तंत्र के बारे में जानेंगे।

## प्रमुख सीखने के उद्देश्य

इस पाठ के अंत तक, आप:

- MCP क्लाइंट-सर्वर आर्किटेक्चर को समझेंगे।  
- होस्ट्स, क्लाइंट्स, और सर्वर्स की भूमिकाओं और जिम्मेदारियों की पहचान करेंगे।  
- MCP को एक लचीली इंटीग्रेशन लेयर बनाने वाली कोर विशेषताओं का विश्लेषण करेंगे।  
- MCP इकोसिस्टम के भीतर जानकारी के प्रवाह को समझेंगे।  
- .NET, Java, Python, और JavaScript में कोड उदाहरणों के माध्यम से व्यावहारिक अंतर्दृष्टि प्राप्त करेंगे।  

## MCP आर्किटेक्चर: गहराई से देखना

MCP इकोसिस्टम एक क्लाइंट-सर्वर मॉडल पर आधारित है। यह मॉड्यूलर संरचना एआई एप्लिकेशन को टूल्स, डेटाबेस, APIs, और संदर्भात्मक संसाधनों के साथ कुशलतापूर्वक इंटरैक्ट करने की अनुमति देती है। आइए इस आर्किटेक्चर को इसके कोर घटकों में विभाजित करें।

MCP मूल रूप से एक क्लाइंट-सर्वर आर्किटेक्चर का अनुसरण करता है, जहां एक होस्ट एप्लिकेशन कई सर्वर्स से कनेक्ट कर सकता है:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP होस्ट्स**: VSCode, Claude Desktop, IDEs, या एआई टूल्स जैसे प्रोग्राम जो MCP के माध्यम से डेटा एक्सेस करना चाहते हैं।  
- **MCP क्लाइंट्स**: प्रोटोकॉल क्लाइंट्स जो सर्वर्स के साथ 1:1 कनेक्शन बनाए रखते हैं।  
- **MCP सर्वर्स**: हल्के प्रोग्राम जो मानकीकृत मॉडल कॉन्टेक्स्ट प्रोटोकॉल के माध्यम से विशिष्ट क्षमताओं को उजागर करते हैं।  
- **स्थानीय डेटा स्रोत**: आपके कंप्यूटर की फाइलें, डेटाबेस, और सेवाएँ जिन्हें MCP सर्वर्स सुरक्षित रूप से एक्सेस कर सकते हैं।  
- **रिमोट सेवाएँ**: इंटरनेट पर उपलब्ध बाहरी सिस्टम जिन्हें MCP सर्वर्स APIs के माध्यम से कनेक्ट कर सकते हैं।  

MCP प्रोटोकॉल एक विकसित मानक है जो डेट-आधारित वर्जनिंग (YYYY-MM-DD फॉर्मेट) का उपयोग करता है। वर्तमान प्रोटोकॉल संस्करण **2025-06-18** है। आप [प्रोटोकॉल स्पेसिफिकेशन](https://modelcontextprotocol.io/specification/2025-06-18/) में नवीनतम अपडेट देख सकते हैं।

### 1. होस्ट्स

मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP) में, **होस्ट्स** एआई एप्लिकेशन हैं जो प्रोटोकॉल के माध्यम से उपयोगकर्ताओं के इंटरफेस के रूप में कार्य करते हैं। होस्ट्स कई MCP सर्वर्स से कनेक्शन को समन्वित और प्रबंधित करते हैं, प्रत्येक सर्वर कनेक्शन के लिए समर्पित MCP क्लाइंट्स बनाते हैं। होस्ट्स के उदाहरणों में शामिल हैं:

- **एआई एप्लिकेशन**: Claude Desktop, Visual Studio Code, Claude Code  
- **डेवलपमेंट एनवायरनमेंट्स**: MCP इंटीग्रेशन वाले IDEs और कोड एडिटर्स  
- **कस्टम एप्लिकेशन**: उद्देश्य-निर्मित एआई एजेंट्स और टूल्स  

**होस्ट्स** एआई मॉडल इंटरैक्शन को समन्वित करने वाले एप्लिकेशन हैं। वे:

- **एआई मॉडल्स का संचालन**: प्रतिक्रियाएँ उत्पन्न करने और एआई वर्कफ़्लो को समन्वित करने के लिए LLMs को निष्पादित या इंटरैक्ट करते हैं।  
- **क्लाइंट कनेक्शन प्रबंधन**: प्रत्येक MCP सर्वर कनेक्शन के लिए एक MCP क्लाइंट बनाते और बनाए रखते हैं।  
- **यूजर इंटरफेस नियंत्रण**: बातचीत प्रवाह, उपयोगकर्ता इंटरैक्शन, और प्रतिक्रिया प्रस्तुति को संभालते हैं।  
- **सुरक्षा लागू करना**: अनुमतियों, सुरक्षा सीमाओं, और प्रमाणीकरण को नियंत्रित करते हैं।  
- **उपयोगकर्ता सहमति संभालना**: डेटा साझा करने और टूल निष्पादन के लिए उपयोगकर्ता की स्वीकृति का प्रबंधन करते हैं।  

### 2. क्लाइंट्स

**क्लाइंट्स** महत्वपूर्ण घटक हैं जो होस्ट्स और MCP सर्वर्स के बीच समर्पित एक-से-एक कनेक्शन बनाए रखते हैं। प्रत्येक MCP क्लाइंट को होस्ट द्वारा एक विशिष्ट MCP सर्वर से कनेक्ट करने के लिए इंस्टेंटिएट किया जाता है, जिससे संगठित और सुरक्षित संचार चैनल सुनिश्चित होते हैं। कई क्लाइंट्स होस्ट्स को एक साथ कई सर्वर्स से कनेक्ट करने की अनुमति देते हैं।

**क्लाइंट्स** होस्ट एप्लिकेशन के भीतर कनेक्टर घटक हैं। वे:

- **प्रोटोकॉल संचार**: सर्वर्स को JSON-RPC 2.0 अनुरोध भेजते हैं, जिसमें प्रॉम्प्ट्स और निर्देश शामिल होते हैं।  
- **क्षमता वार्ता**: सर्वर्स के साथ प्रारंभिककरण के दौरान समर्थित सुविधाओं और प्रोटोकॉल संस्करणों पर बातचीत करते हैं।  
- **टूल निष्पादन**: मॉडल्स से टूल निष्पादन अनुरोधों को प्रबंधित करते हैं और प्रतिक्रियाओं को संसाधित करते हैं।  
- **रियल-टाइम अपडेट्स**: सर्वर्स से सूचनाएँ और रियल-टाइम अपडेट्स को संभालते हैं।  
- **प्रतिक्रिया प्रसंस्करण**: उपयोगकर्ताओं को प्रदर्शित करने के लिए सर्वर प्रतिक्रियाओं को संसाधित और प्रारूपित करते हैं।  

### 3. सर्वर्स

**सर्वर्स** प्रोग्राम हैं जो MCP क्लाइंट्स को संदर्भ, टूल्स, और क्षमताएँ प्रदान करते हैं। वे स्थानीय रूप से (होस्ट के समान मशीन पर) या रिमोटली (बाहरी प्लेटफॉर्म पर) निष्पादित हो सकते हैं और क्लाइंट अनुरोधों को संभालने और संरचित प्रतिक्रियाएँ प्रदान करने के लिए जिम्मेदार होते हैं। सर्वर्स मानकीकृत मॉडल कॉन्टेक्स्ट प्रोटोकॉल के माध्यम से विशिष्ट कार्यक्षमता को उजागर करते हैं।

**सर्वर्स** सेवाएँ हैं जो संदर्भ और क्षमताएँ प्रदान करती हैं। वे:

- **फीचर पंजीकरण**: उपलब्ध प्रिमिटिव्स (संसाधन, प्रॉम्प्ट्स, टूल्स) को क्लाइंट्स के लिए पंजीकृत और उजागर करते हैं।  
- **अनुरोध प्रसंस्करण**: क्लाइंट्स से टूल कॉल्स, संसाधन अनुरोधों, और प्रॉम्प्ट अनुरोधों को प्राप्त और निष्पादित करते हैं।  
- **संदर्भ प्रावधान**: मॉडल प्रतिक्रियाओं को बढ़ाने के लिए संदर्भात्मक जानकारी और डेटा प्रदान करते हैं।  
- **स्टेट प्रबंधन**: सत्र स्थिति बनाए रखते हैं और आवश्यक होने पर स्टेटफुल इंटरैक्शन को संभालते हैं।  
- **रियल-टाइम सूचनाएँ**: कनेक्टेड क्लाइंट्स को क्षमता परिवर्तनों और अपडेट्स के बारे में सूचनाएँ भेजते हैं।  

सर्वर्स को कोई भी विकसित कर सकता है ताकि मॉडल क्षमताओं को विशेष कार्यक्षमता के साथ विस्तारित किया जा सके, और वे स्थानीय और रिमोट दोनों परिनियोजन परिदृश्यों का समर्थन करते हैं।

### 4. सर्वर प्रिमिटिव्स

मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP) में सर्वर्स तीन कोर **प्रिमिटिव्स** प्रदान करते हैं जो क्लाइंट्स, होस्ट्स, और भाषा मॉडल्स के बीच समृद्ध इंटरैक्शन के लिए मौलिक निर्माण खंडों को परिभाषित करते हैं। ये प्रिमिटिव्स प्रोटोकॉल के माध्यम से उपलब्ध संदर्भात्मक जानकारी और क्रियाओं के प्रकार निर्दिष्ट करते हैं।

MCP सर्वर्स निम्नलिखित तीन कोर प्रिमिटिव्स का कोई भी संयोजन उजागर कर सकते हैं:

#### संसाधन

**संसाधन** डेटा स्रोत हैं जो एआई एप्लिकेशन को संदर्भात्मक जानकारी प्रदान करते हैं। वे स्थिर या गतिशील सामग्री का प्रतिनिधित्व करते हैं जो मॉडल की समझ और निर्णय लेने को बढ़ा सकती है:

- **संदर्भात्मक डेटा**: एआई मॉडल उपभोग के लिए संरचित जानकारी और संदर्भ।  
- **ज्ञान आधार**: दस्तावेज़ रिपॉजिटरी, लेख, मैनुअल, और शोध पत्र।  
- **स्थानीय डेटा स्रोत**: फाइलें, डेटाबेस, और स्थानीय सिस्टम जानकारी।  
- **बाहरी डेटा**: API प्रतिक्रियाएँ, वेब सेवाएँ, और रिमोट सिस्टम डेटा।  
- **गतिशील सामग्री**: बाहरी परिस्थितियों के आधार पर अपडेट होने वाला रियल-टाइम डेटा।  

संसाधनों की पहचान URIs द्वारा की जाती है और `resources/list` के माध्यम से खोज और `resources/read` विधियों के माध्यम से पुनर्प्राप्ति का समर्थन करते हैं:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### प्रॉम्प्ट्स

**प्रॉम्प्ट्स** पुन: उपयोग योग्य टेम्पलेट्स हैं जो भाषा मॉडल्स के साथ इंटरैक्शन को संरचित करने में मदद करते हैं। वे मानकीकृत इंटरैक्शन पैटर्न और टेम्पलेटेड वर्कफ़्लो प्रदान करते हैं:

- **टेम्पलेट-आधारित इंटरैक्शन**: पूर्व-संरचित संदेश और बातचीत शुरू करने वाले।  
- **वर्कफ़्लो टेम्पलेट्स**: सामान्य कार्यों और इंटरैक्शन के लिए मानकीकृत अनुक्रम।  
- **फ्यू-शॉट उदाहरण**: मॉडल निर्देश के लिए उदाहरण-आधारित टेम्पलेट्स।  
- **सिस्टम प्रॉम्प्ट्स**: मॉडल व्यवहार और संदर्भ को परिभाषित करने वाले आधारभूत प्रॉम्प्ट्स।  
- **गतिशील टेम्पलेट्स**: विशिष्ट संदर्भों के लिए अनुकूलित पैरामीटरयुक्त प्रॉम्प्ट्स।  

प्रॉम्प्ट्स वेरिएबल सब्स्टीट्यूशन का समर्थन करते हैं और `prompts/list` के माध्यम से खोज और `prompts/get` के साथ पुनर्प्राप्त किए जा सकते हैं:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### टूल्स

**टूल्स** निष्पादन योग्य कार्य हैं जिन्हें एआई मॉडल्स विशिष्ट क्रियाएँ करने के लिए बुला सकते हैं। वे MCP इकोसिस्टम के "क्रियाएँ" का प्रतिनिधित्व करते हैं, जो मॉडल्स को बाहरी सिस्टम्स के साथ इंटरैक्ट करने में सक्षम बनाते हैं:

- **निष्पादन योग्य कार्य**: विशिष्ट पैरामीटर के साथ मॉडल्स द्वारा बुलाए जाने वाले अलग-अलग ऑपरेशन्स।  
- **बाहरी सिस्टम इंटीग्रेशन**: API कॉल्स, डेटाबेस क्वेरीज़, फाइल ऑपरेशन्स, गणनाएँ।  
- **अद्वितीय पहचान**: प्रत्येक टूल का एक विशिष्ट नाम, विवरण, और पैरामीटर स्कीमा होता है।  
- **संरचित I/O**: टूल्स मान्य पैरामीटर स्वीकार करते हैं और संरचित, टाइप्ड प्रतिक्रियाएँ लौटाते हैं।  
- **क्रिया क्षमताएँ**: मॉडल्स को वास्तविक दुनिया की क्रियाएँ करने और लाइव डेटा प्राप्त करने में सक्षम बनाते हैं।  

टूल्स JSON स्कीमा के साथ पैरामीटर मान्यता के लिए परिभाषित किए जाते हैं और `tools/list` के माध्यम से खोजे जाते हैं और `tools/call` के माध्यम से निष्पादित किए जाते हैं:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## क्लाइंट प्रिमिटिव्स

मॉडल कॉन्टेक्स्ट प्रोटोकॉल (MCP) में, **क्लाइंट्स** प्रिमिटिव्स को उजागर कर सकते हैं जो सर्वर्स को होस्ट एप्लिकेशन से अतिरिक्त क्षमताओं का अनुरोध करने की अनुमति देते हैं। ये क्लाइंट-साइड प्रिमिटिव्स समृद्ध, अधिक इंटरैक्टिव सर्वर कार्यान्वयन को सक्षम करते हैं जो एआई मॉडल क्षमताओं और उपयोगकर्ता इंटरैक्शन तक पहुँच सकते हैं।

### सैंपलिंग

**सैंपलिंग** सर्वर्स को क्लाइंट के एआई एप्लिकेशन से भाषा मॉडल पूर्णता का अनुरोध करने की अनुमति देता है। यह प्रिमिटिव सर्वर्स को अपने मॉडल निर्भरताओं को एम्बेड किए बिना LLM क्षमताओं तक पहुँचने में सक्षम बनाता है:

- **मॉडल-स्वतंत्र एक्सेस**: सर्वर्स पूर्णता का अनुरोध कर सकते हैं बिना LLM SDKs को शामिल किए या मॉडल एक्सेस का प्रबंधन किए।  
- **सर्वर-आरंभित एआई**: सर्वर्स को क्लाइंट के एआई मॉडल का उपयोग करके सामग्री उत्पन्न करने में सक्षम बनाता है।  
- **पुनरावर्ती LLM इंटरैक्शन**: जटिल परिदृश्यों का समर्थन करता है जहां सर्वर्स को प्रसंस्करण के लिए एआई सहायता की आवश्यकता होती है।  
- **गतिशील सामग्री निर्माण**: होस्ट के मॉडल का उपयोग करके संदर्भात्मक प्रतिक्रियाएँ बनाने के लिए सर्वर्स को सक्षम बनाता है।  

सैंपलिंग `sampling/complete` विधि के माध्यम से शुरू की जाती है, जहां सर्वर्स क्लाइंट्स को पूर्णता अनुरोध भेजते हैं।

### जानकारी प्राप्त करना  

**जानकारी प्राप्त करना** सर्वर्स को क्लाइंट इंटरफेस के माध्यम से उपयोगकर्ताओं से अतिरिक्त जानकारी या पुष्टि का अनुरोध करने की अनुमति देता है:

- **उपयोगकर्ता इनपुट अनुरोध**: टूल निष्पादन के लिए आवश्यक होने पर सर्वर्स अतिरिक्त जानकारी मांग सकते हैं।  
- **पुष्टि संवाद**: संवेदनशील या प्रभावशाली ऑपरेशन्स के लिए उपयोगकर्ता की स्वीकृति का अनुरोध करें।  
- **इंटरैक्टिव वर्कफ़्लो**: सर्वर्स को चरण-दर-चरण उपयोगकर्ता इंटरैक्शन बनाने में सक्षम बनाता है।  
- **गतिशील पैरामीटर संग्रह**: टूल निष्पादन के दौरान गायब या वैकल्पिक पैरामीटर एकत्र करें।  

जानकारी प्राप्त करने के अनुरोध `elicitation/request` विधि का उपयोग करके किए जाते हैं ताकि क्लाइंट के इंटरफेस के माध्यम से उपयोगकर्ता इनपुट एकत्र किया जा सके।

### लॉगिंग

**लॉगिंग** सर्वर्स को क्लाइंट्स को संरचित लॉग संदेश भेजने की अनुमति देता है ताकि डिबगिंग, निगरानी, और संचालन दृश्यता प्रदान की जा सके:

- **डिबगिंग समर्थन**: सर्वर्स को समस्या निवारण के लिए विस्तृत निष्पादन लॉग प्रदान करने में सक्षम बनाता है।  
- **संचालन निगरानी**: क्लाइंट्स को स्थिति अपडेट्स और प्रदर्शन मेट्रिक्स भेजें।  
-
- **JSON-RPC 2.0 प्रोटोकॉल**: सभी संचार विधियों के लिए JSON-RPC 2.0 संदेश प्रारूप का उपयोग करता है, जिसमें विधि कॉल, प्रतिक्रियाएँ और सूचनाएँ शामिल हैं  
- **लाइफसाइकल प्रबंधन**: क्लाइंट और सर्वर के बीच कनेक्शन प्रारंभ, क्षमता वार्ता, और सत्र समाप्ति को संभालता है  
- **सर्वर प्रिमिटिव्स**: सर्वर को टूल्स, संसाधनों और प्रॉम्प्ट्स के माध्यम से मुख्य कार्यक्षमता प्रदान करने में सक्षम बनाता है  
- **क्लाइंट प्रिमिटिव्स**: सर्वर को LLM से सैंपलिंग का अनुरोध करने, उपयोगकर्ता इनपुट प्राप्त करने और लॉग संदेश भेजने में सक्षम बनाता है  
- **रियल-टाइम सूचनाएँ**: बिना बार-बार अनुरोध किए, डायनामिक अपडेट के लिए असिंक्रोनस सूचनाओं का समर्थन करता है  

#### मुख्य विशेषताएँ:

- **प्रोटोकॉल संस्करण वार्ता**: संगतता सुनिश्चित करने के लिए दिनांक-आधारित संस्करणिंग (YYYY-MM-DD) का उपयोग करता है  
- **क्षमता खोज**: प्रारंभिक चरण में क्लाइंट और सर्वर समर्थित फीचर जानकारी का आदान-प्रदान करते हैं  
- **स्टेटफुल सत्र**: संदर्भ निरंतरता के लिए कई इंटरैक्शन के दौरान कनेक्शन स्थिति बनाए रखता है  

### ट्रांसपोर्ट लेयर

**ट्रांसपोर्ट लेयर** MCP प्रतिभागियों के बीच संचार चैनलों, संदेश फ्रेमिंग, और प्रमाणीकरण को प्रबंधित करता है:

#### समर्थित ट्रांसपोर्ट तंत्र:

1. **STDIO ट्रांसपोर्ट**:
   - सीधे प्रक्रिया संचार के लिए मानक इनपुट/आउटपुट स्ट्रीम का उपयोग करता है  
   - एक ही मशीन पर स्थानीय प्रक्रियाओं के लिए इष्टतम, बिना नेटवर्क ओवरहेड के  
   - आमतौर पर स्थानीय MCP सर्वर कार्यान्वयन के लिए उपयोग किया जाता है  

2. **स्ट्रीमेबल HTTP ट्रांसपोर्ट**:
   - क्लाइंट-से-सर्वर संदेशों के लिए HTTP POST का उपयोग करता है  
   - सर्वर-से-क्लाइंट स्ट्रीमिंग के लिए वैकल्पिक सर्वर-सेंट इवेंट्स (SSE)  
   - नेटवर्क के पार रिमोट सर्वर संचार को सक्षम बनाता है  
   - मानक HTTP प्रमाणीकरण (बेयरर टोकन, API कुंजी, कस्टम हेडर) का समर्थन करता है  
   - सुरक्षित टोकन-आधारित प्रमाणीकरण के लिए MCP OAuth की सिफारिश करता है  

#### ट्रांसपोर्ट अमूर्तता:

ट्रांसपोर्ट लेयर डेटा लेयर से संचार विवरण को अमूर्त करता है, जिससे सभी ट्रांसपोर्ट तंत्रों में समान JSON-RPC 2.0 संदेश प्रारूप का उपयोग किया जा सके। यह अमूर्तता अनुप्रयोगों को स्थानीय और रिमोट सर्वरों के बीच सहजता से स्विच करने की अनुमति देती है।  

### सुरक्षा विचार

MCP कार्यान्वयन को सभी प्रोटोकॉल संचालन में सुरक्षित, भरोसेमंद और सुरक्षित इंटरैक्शन सुनिश्चित करने के लिए कई महत्वपूर्ण सुरक्षा सिद्धांतों का पालन करना चाहिए:

- **उपयोगकर्ता सहमति और नियंत्रण**: किसी भी डेटा तक पहुँचने या संचालन करने से पहले उपयोगकर्ताओं को स्पष्ट सहमति प्रदान करनी चाहिए। उन्हें यह स्पष्ट नियंत्रण होना चाहिए कि कौन सा डेटा साझा किया जा रहा है और कौन सी क्रियाएँ अधिकृत हैं, और इसके लिए सहज उपयोगकर्ता इंटरफेस प्रदान किए जाने चाहिए।  

- **डेटा गोपनीयता**: उपयोगकर्ता डेटा को केवल स्पष्ट सहमति के साथ उजागर किया जाना चाहिए और उचित एक्सेस नियंत्रण द्वारा संरक्षित किया जाना चाहिए। MCP कार्यान्वयन को अनधिकृत डेटा ट्रांसमिशन से बचाना चाहिए और सभी इंटरैक्शन के दौरान गोपनीयता बनाए रखनी चाहिए।  

- **टूल सुरक्षा**: किसी भी टूल को सक्रिय करने से पहले स्पष्ट उपयोगकर्ता सहमति आवश्यक है। उपयोगकर्ताओं को प्रत्येक टूल की कार्यक्षमता का स्पष्ट समझ होना चाहिए, और अनपेक्षित या असुरक्षित टूल निष्पादन को रोकने के लिए मजबूत सुरक्षा सीमाएँ लागू की जानी चाहिए।  

इन सुरक्षा सिद्धांतों का पालन करके, MCP यह सुनिश्चित करता है कि उपयोगकर्ता का विश्वास, गोपनीयता और सुरक्षा सभी प्रोटोकॉल इंटरैक्शन में बनाए रखा जाए, जबकि शक्तिशाली AI एकीकरण को सक्षम किया जाए।  

## कोड उदाहरण: मुख्य घटक

नीचे कई लोकप्रिय प्रोग्रामिंग भाषाओं में कोड उदाहरण दिए गए हैं, जो यह दिखाते हैं कि मुख्य MCP सर्वर घटकों और टूल्स को कैसे कार्यान्वित किया जाए।  

### .NET उदाहरण: टूल्स के साथ एक सरल MCP सर्वर बनाना

यहाँ एक व्यावहारिक .NET कोड उदाहरण दिया गया है, जो यह दिखाता है कि कस्टम टूल्स के साथ एक सरल MCP सर्वर को कैसे कार्यान्वित किया जाए। यह उदाहरण टूल्स को परिभाषित और पंजीकृत करने, अनुरोधों को संभालने, और सर्वर को Model Context Protocol से जोड़ने का प्रदर्शन करता है।  

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```  

### जावा उदाहरण: MCP सर्वर घटक

यह उदाहरण ऊपर दिए गए .NET उदाहरण के समान MCP सर्वर और टूल पंजीकरण को प्रदर्शित करता है, लेकिन इसे जावा में कार्यान्वित किया गया है।  

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```  

### पायथन उदाहरण: MCP सर्वर बनाना

इस उदाहरण में, हम दिखाते हैं कि पायथन में MCP सर्वर कैसे बनाया जाए। इसमें टूल्स बनाने के दो अलग-अलग तरीके भी दिखाए गए हैं।  

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```  

### जावास्क्रिप्ट उदाहरण: MCP सर्वर बनाना

यह उदाहरण दिखाता है कि जावास्क्रिप्ट में MCP सर्वर कैसे बनाया जाए और दो मौसम-संबंधित टूल्स को कैसे पंजीकृत किया जाए।  

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```  

यह जावास्क्रिप्ट उदाहरण यह भी दिखाता है कि एक MCP क्लाइंट कैसे बनाया जाए, जो सर्वर से कनेक्ट होता है, एक प्रॉम्प्ट भेजता है, और प्रतिक्रिया को प्रोसेस करता है, जिसमें किए गए किसी भी टूल कॉल को शामिल किया गया है।  

## सुरक्षा और प्राधिकरण

MCP में प्रोटोकॉल के दौरान सुरक्षा और प्राधिकरण को प्रबंधित करने के लिए कई अंतर्निहित अवधारणाएँ और तंत्र शामिल हैं:  

1. **टूल अनुमति नियंत्रण**:  
   क्लाइंट निर्दिष्ट कर सकते हैं कि सत्र के दौरान मॉडल को कौन से टूल्स का उपयोग करने की अनुमति है। यह सुनिश्चित करता है कि केवल स्पष्ट रूप से अधिकृत टूल्स ही सुलभ हों, जिससे अनपेक्षित या असुरक्षित संचालन का जोखिम कम हो। अनुमतियाँ उपयोगकर्ता प्राथमिकताओं, संगठनात्मक नीतियों, या इंटरैक्शन के संदर्भ के आधार पर गतिशील रूप से कॉन्फ़िगर की जा सकती हैं।  

2. **प्रमाणीकरण**:  
   सर्वर टूल्स, संसाधनों, या संवेदनशील संचालन तक पहुँच प्रदान करने से पहले प्रमाणीकरण की आवश्यकता कर सकते हैं। इसमें API कुंजी, OAuth टोकन, या अन्य प्रमाणीकरण योजनाएँ शामिल हो सकती हैं। उचित प्रमाणीकरण यह सुनिश्चित करता है कि केवल भरोसेमंद क्लाइंट और उपयोगकर्ता ही सर्वर-साइड क्षमताओं को सक्रिय कर सकें।  

3. **सत्यापन**:  
   सभी टूल सक्रियणों के लिए पैरामीटर सत्यापन लागू किया जाता है। प्रत्येक टूल अपने पैरामीटर के अपेक्षित प्रकार, प्रारूप, और बाधाओं को परिभाषित करता है, और सर्वर आने वाले अनुरोधों को उसी के अनुसार सत्यापित करता है। यह खराब या दुर्भावनापूर्ण इनपुट को टूल कार्यान्वयन तक पहुँचने से रोकता है और संचालन की अखंडता बनाए रखने में मदद करता है।  

4. **दर सीमित करना**:  
   दुरुपयोग को रोकने और सर्वर संसाधनों के उचित उपयोग को सुनिश्चित करने के लिए, MCP सर्वर टूल कॉल और संसाधन एक्सेस के लिए दर सीमित कर सकते हैं। दर सीमाएँ प्रति उपयोगकर्ता, प्रति सत्र, या वैश्विक रूप से लागू की जा सकती हैं, और सेवा इनकार हमलों या अत्यधिक संसाधन खपत से बचाने में मदद करती हैं।  

इन तंत्रों को मिलाकर, MCP भाषा मॉडल को बाहरी टूल्स और डेटा स्रोतों के साथ एकीकृत करने के लिए एक सुरक्षित आधार प्रदान करता है, जबकि उपयोगकर्ताओं और डेवलपर्स को एक्सेस और उपयोग पर सूक्ष्म नियंत्रण देता है।  

## प्रोटोकॉल संदेश और संचार प्रवाह

MCP संचार **JSON-RPC 2.0** संदेशों का उपयोग करता है, जो होस्ट, क्लाइंट और सर्वर के बीच स्पष्ट और विश्वसनीय इंटरैक्शन की सुविधा प्रदान करता है। प्रोटोकॉल विभिन्न प्रकार के संचालन के लिए विशिष्ट संदेश पैटर्न परिभाषित करता है:  

### मुख्य संदेश प्रकार:

#### **प्रारंभिक संदेश**
- **`initialize` अनुरोध**: कनेक्शन स्थापित करता है और प्रोटोकॉल संस्करण और क्षमताओं पर बातचीत करता है  
- **`initialize` प्रतिक्रिया**: समर्थित सुविधाओं और सर्वर जानकारी की पुष्टि करता है  
- **`notifications/initialized`**: संकेत देता है कि प्रारंभिक प्रक्रिया पूरी हो गई है और सत्र तैयार है  

#### **खोज संदेश**
- **`tools/list` अनुरोध**: सर्वर से उपलब्ध टूल्स की खोज करता है  
- **`resources/list` अनुरोध**: उपलब्ध संसाधनों (डेटा स्रोतों) की सूची प्राप्त करता है  
- **`prompts/list` अनुरोध**: उपलब्ध प्रॉम्प्ट टेम्पलेट्स को पुनः प्राप्त करता है  

#### **निष्पादन संदेश**  
- **`tools/call` अनुरोध**: प्रदान किए गए पैरामीटर के साथ एक विशिष्ट टूल निष्पादित करता है  
- **`resources/read` अनुरोध**: एक विशिष्ट संसाधन से सामग्री पुनः प्राप्त करता है  
- **`prompts/get` अनुरोध**: वैकल्पिक पैरामीटर के साथ एक प्रॉम्प्ट टेम्पलेट पुनः प्राप्त करता है  

#### **क्लाइंट-साइड संदेश**
- **`sampling/complete` अनुरोध**: सर्वर क्लाइंट से LLM पूर्णता का अनुरोध करता है  
- **`elicitation/request`**: सर्वर क्लाइंट इंटरफ़ेस के माध्यम से उपयोगकर्ता इनपुट का अनुरोध करता है  
- **लॉगिंग संदेश**: सर्वर क्लाइंट को संरचित लॉग संदेश भेजता है  

#### **सूचना संदेश**
- **`notifications/tools/list_changed`**: सर्वर क्लाइंट को टूल परिवर्तनों की सूचना देता है  
- **`notifications/resources/list_changed`**: सर्वर क्लाइंट को संसाधन परिवर्तनों की सूचना देता है  
- **`notifications/prompts/list_changed`**: सर्वर क्लाइंट को प्रॉम्प्ट परिवर्तनों की सूचना देता है  

### संदेश संरचना:

सभी MCP संदेश JSON-RPC 2.0 प्रारूप का पालन करते हैं, जिसमें शामिल हैं:  
- **अनुरोध संदेश**: `id`, `method`, और वैकल्पिक `params` शामिल करते हैं  
- **प्रतिक्रिया संदेश**: `id` और `result` या `error` शामिल करते हैं  
- **सूचना संदेश**: `method` और वैकल्पिक `params` शामिल करते हैं (कोई `id` या प्रतिक्रिया अपेक्षित नहीं)  

यह संरचित संचार विश्वसनीय, ट्रेस करने योग्य, और विस्तार योग्य इंटरैक्शन सुनिश्चित करता है, जो रियल-टाइम अपडेट, टूल चेनिंग, और मजबूत त्रुटि प्रबंधन जैसे उन्नत परिदृश्यों का समर्थन करता है।  

## मुख्य निष्कर्ष

- **आर्किटेक्चर**: MCP एक क्लाइंट-सर्वर आर्किटेक्चर का उपयोग करता है, जहाँ होस्ट कई क्लाइंट कनेक्शनों को प्रबंधित करते हैं  
- **प्रतिभागी**: पारिस्थितिकी तंत्र में होस्ट (AI एप्लिकेशन), क्लाइंट (प्रोटोकॉल कनेक्टर), और सर्वर (क्षमता प्रदाता) शामिल हैं  
- **ट्रांसपोर्ट तंत्र**: संचार STDIO (स्थानीय) और स्ट्रीमेबल HTTP के साथ वैकल्पिक SSE (रिमोट) का समर्थन करता है  
- **मुख्य प्रिमिटिव्स**: सर्वर टूल्स (निष्पादन योग्य कार्य), संसाधन (डेटा स्रोत), और प्रॉम्प्ट्स (टेम्पलेट्स) को उजागर करते हैं  
- **क्लाइंट प्रिमिटिव्स**: सर्वर क्लाइंट से सैंपलिंग (LLM पूर्णता), उपयोगकर्ता इनपुट, और लॉगिंग का अनुरोध कर सकते हैं  
- **प्रोटोकॉल नींव**: JSON-RPC 2.0 पर आधारित, दिनांक-आधारित संस्करणिंग के साथ (वर्तमान: 2025-06-18)  
- **रियल-टाइम क्षमताएँ**: डायनामिक अपडेट और रियल-टाइम सिंक्रोनाइज़ेशन के लिए सूचनाओं का समर्थन करता है  
- **सुरक्षा पहले**: स्पष्ट उपयोगकर्ता सहमति, डेटा गोपनीयता सुरक्षा, और सुरक्षित ट्रांसपोर्ट मुख्य आवश्यकताएँ हैं  

## अभ्यास

अपने डोमेन में उपयोगी एक सरल MCP टूल डिज़ाइन करें। परिभाषित करें:  
1. टूल का नाम क्या होगा  
2. यह कौन से पैरामीटर स्वीकार करेगा  
3. यह क्या आउटपुट लौटाएगा  
4. एक मॉडल इस टूल का उपयोग करके उपयोगकर्ता की समस्याओं को कैसे हल कर सकता है  

---

## आगे क्या है

अगला: [अध्याय 2: सुरक्षा](../02-Security/README.md)  

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम उत्तरदायी नहीं हैं।