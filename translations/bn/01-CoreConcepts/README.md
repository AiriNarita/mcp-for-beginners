<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0a6a7bcb289c024a91289e0444cb370b",
  "translation_date": "2025-08-18T14:52:37+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "bn"
}
-->
# MCP মূল ধারণা: AI ইন্টিগ্রেশনের জন্য মডেল কনটেক্সট প্রোটোকল আয়ত্ত করা

[![MCP মূল ধারণা](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.bn.png)](https://youtu.be/earDzWGtE84)

_(উপরের ছবিতে ক্লিক করে এই পাঠের ভিডিও দেখুন)_

[Model Context Protocol (MCP)](https://gi- **স্পষ্ট ব্যবহারকারীর সম্মতি**: সমস্ত ডেটা অ্যাক্সেস এবং অপারেশন কার্যকর করার আগে ব্যবহারকারীর স্পষ্ট অনুমোদন প্রয়োজন। ব্যবহারকারীদের স্পষ্টভাবে বুঝতে হবে কোন ডেটা অ্যাক্সেস করা হবে এবং কোন কাজগুলি সম্পন্ন হবে, এবং অনুমতি ও অনুমোদনের উপর বিস্তারিত নিয়ন্ত্রণ থাকতে হবে।

- **ডেটা গোপনীয়তা সুরক্ষা**: ব্যবহারকারীর ডেটা শুধুমাত্র স্পষ্ট সম্মতির মাধ্যমে প্রকাশ করা হবে এবং পুরো ইন্টারঅ্যাকশন লাইফসাইকেল জুড়ে শক্তিশালী অ্যাক্সেস নিয়ন্ত্রণ দ্বারা সুরক্ষিত থাকতে হবে। অননুমোদিত ডেটা প্রেরণ প্রতিরোধ করতে হবে এবং কঠোর গোপনীয়তার সীমানা বজায় রাখতে হবে।

- **টুল কার্যকর করার নিরাপত্তা**: প্রতিটি টুল চালানোর জন্য ব্যবহারকারীর স্পষ্ট সম্মতি প্রয়োজন, যেখানে টুলের কার্যকারিতা, প্যারামিটার এবং সম্ভাব্য প্রভাব সম্পর্কে পরিষ্কার ধারণা থাকতে হবে। অনিচ্ছাকৃত, অনিরাপদ বা ক্ষতিকারক টুল কার্যকর প্রতিরোধ করার জন্য শক্তিশালী নিরাপত্তা সীমানা থাকতে হবে।

- **ট্রান্সপোর্ট লেয়ার সিকিউরিটি**: সমস্ত যোগাযোগ চ্যানেলে উপযুক্ত এনক্রিপশন এবং প্রমাণীকরণ পদ্ধতি ব্যবহার করা উচিত। দূরবর্তী সংযোগগুলিতে নিরাপদ ট্রান্সপোর্ট প্রোটোকল এবং সঠিক ক্রেডেনশিয়াল ব্যবস্থাপনা প্রয়োগ করা উচিত।

#### বাস্তবায়ন নির্দেশিকা:

- **অনুমতি ব্যবস্থাপনা**: এমন সূক্ষ্ম-গ্রেড অনুমতি ব্যবস্থা বাস্তবায়ন করুন যা ব্যবহারকারীদের নিয়ন্ত্রণ করতে দেয় কোন সার্ভার, টুল এবং রিসোর্স অ্যাক্সেসযোগ্য
- **প্রমাণীকরণ ও অনুমোদন**: সুরক্ষিত প্রমাণীকরণ পদ্ধতি (OAuth, API কী) ব্যবহার করুন সঠিক টোকেন ব্যবস্থাপনা এবং মেয়াদ শেষ হওয়ার সাথে  
- **ইনপুট যাচাইকরণ**: ইনজেকশন আক্রমণ প্রতিরোধ করতে সংজ্ঞায়িত স্কিমা অনুযায়ী সমস্ত প্যারামিটার এবং ডেটা ইনপুট যাচাই করুন
- **অডিট লগিং**: নিরাপত্তা পর্যবেক্ষণ এবং সম্মতির জন্য সমস্ত অপারেশনের ব্যাপক লগ বজায় রাখুন

## সংক্ষিপ্ত বিবরণ

এই পাঠটি Model Context Protocol (MCP) ইকোসিস্টেমের মৌলিক স্থাপত্য এবং উপাদানগুলি অন্বেষণ করে। আপনি MCP ইন্টারঅ্যাকশনের শক্তি প্রদানকারী ক্লায়েন্ট-সার্ভার স্থাপত্য, মূল উপাদান এবং যোগাযোগের প্রক্রিয়া সম্পর্কে শিখবেন।

## মূল শিক্ষার উদ্দেশ্য

এই পাঠের শেষে, আপনি:

- MCP ক্লায়েন্ট-সার্ভার স্থাপত্য বুঝতে পারবেন।
- হোস্ট, ক্লায়েন্ট এবং সার্ভারের ভূমিকা এবং দায়িত্ব চিহ্নিত করতে পারবেন।
- MCP কে একটি নমনীয় ইন্টিগ্রেশন লেয়ার হিসেবে গড়ে তোলার মূল বৈশিষ্ট্যগুলি বিশ্লেষণ করতে পারবেন।
- MCP ইকোসিস্টেমে তথ্য প্রবাহ সম্পর্কে শিখবেন।
- .NET, Java, Python এবং JavaScript-এ কোড উদাহরণের মাধ্যমে ব্যবহারিক অন্তর্দৃষ্টি অর্জন করবেন।

## MCP স্থাপত্য: গভীরভাবে দেখা

MCP ইকোসিস্টেম একটি ক্লায়েন্ট-সার্ভার মডেলের উপর ভিত্তি করে তৈরি। এই মডুলার কাঠামো AI অ্যাপ্লিকেশনগুলিকে টুল, ডেটাবেস, API এবং প্রসঙ্গগত রিসোর্সগুলির সাথে দক্ষতার সাথে ইন্টারঅ্যাক্ট করতে দেয়। আসুন এই স্থাপত্যটি এর মূল উপাদানগুলিতে ভেঙে দেখি।

MCP মূলত একটি ক্লায়েন্ট-সার্ভার স্থাপত্য অনুসরণ করে যেখানে একটি হোস্ট অ্যাপ্লিকেশন একাধিক সার্ভারের সাথে সংযোগ করতে পারে:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP হোস্ট**: VSCode, Claude Desktop, IDEs বা MCP এর মাধ্যমে ডেটা অ্যাক্সেস করতে চায় এমন AI টুলের মতো প্রোগ্রাম
- **MCP ক্লায়েন্ট**: প্রোটোকল ক্লায়েন্ট যা সার্ভারের সাথে 1:1 সংযোগ বজায় রাখে
- **MCP সার্ভার**: হালকা প্রোগ্রাম যা প্রতিটি MCP এর মাধ্যমে নির্দিষ্ট ক্ষমতা প্রকাশ করে
- **স্থানীয় ডেটা উৎস**: MCP সার্ভারগুলি নিরাপদে অ্যাক্সেস করতে পারে এমন আপনার কম্পিউটারের ফাইল, ডেটাবেস এবং পরিষেবা
- **দূরবর্তী পরিষেবা**: API এর মাধ্যমে MCP সার্ভারগুলি সংযোগ করতে পারে এমন ইন্টারনেটের মাধ্যমে উপলব্ধ বাহ্যিক সিস্টেম।

MCP প্রোটোকল একটি তারিখ-ভিত্তিক সংস্করণিং (YYYY-MM-DD ফরম্যাট) ব্যবহার করে একটি বিকাশমান মান। বর্তমান প্রোটোকল সংস্করণ **2025-06-18**। [প্রোটোকল স্পেসিফিকেশন](https://modelcontextprotocol.io/specification/2025-06-18/) এর সর্বশেষ আপডেটগুলি দেখতে পারেন।

### 1. হোস্ট

Model Context Protocol (MCP)-এ, **হোস্ট** হল AI অ্যাপ্লিকেশন যা প্রোটোকলের মাধ্যমে ব্যবহারকারীদের ইন্টারঅ্যাক্ট করার প্রাথমিক ইন্টারফেস হিসেবে কাজ করে। হোস্ট একাধিক MCP সার্ভারের সাথে সংযোগ পরিচালনা করে এবং প্রতিটি সার্ভার সংযোগের জন্য নিবেদিত MCP ক্লায়েন্ট তৈরি করে। হোস্টের উদাহরণগুলির মধ্যে রয়েছে:

- **AI অ্যাপ্লিকেশন**: Claude Desktop, Visual Studio Code, Claude Code
- **উন্নয়ন পরিবেশ**: MCP ইন্টিগ্রেশন সহ IDE এবং কোড এডিটর  
- **কাস্টম অ্যাপ্লিকেশন**: উদ্দেশ্য-নির্মিত AI এজেন্ট এবং টুল

**হোস্ট** হল অ্যাপ্লিকেশন যা AI মডেল ইন্টারঅ্যাকশন সমন্বয় করে। তারা:

- **AI মডেল সমন্বয়**: LLM চালানো বা প্রতিক্রিয়া তৈরি করতে এবং AI ওয়ার্কফ্লো সমন্বয় করতে
- **ক্লায়েন্ট সংযোগ পরিচালনা**: প্রতিটি MCP সার্ভার সংযোগের জন্য একটি MCP ক্লায়েন্ট তৈরি এবং বজায় রাখা
- **ব্যবহারকারী ইন্টারফেস নিয়ন্ত্রণ**: কথোপকথনের প্রবাহ, ব্যবহারকারীর ইন্টারঅ্যাকশন এবং প্রতিক্রিয়া উপস্থাপনা পরিচালনা  
- **নিরাপত্তা প্রয়োগ**: অনুমতি, নিরাপত্তা সীমাবদ্ধতা এবং প্রমাণীকরণ নিয়ন্ত্রণ
- **ব্যবহারকারীর সম্মতি পরিচালনা**: ডেটা শেয়ারিং এবং টুল কার্যকর করার জন্য ব্যবহারকারীর অনুমোদন পরিচালনা

### 2. ক্লায়েন্ট

**ক্লায়েন্ট** হল গুরুত্বপূর্ণ উপাদান যা হোস্ট এবং MCP সার্ভারের মধ্যে নিবেদিত এক-এক সংযোগ বজায় রাখে। প্রতিটি MCP ক্লায়েন্ট একটি নির্দিষ্ট MCP সার্ভারের সাথে সংযোগ করতে হোস্ট দ্বারা তৈরি করা হয়, যা সংগঠিত এবং নিরাপদ যোগাযোগ চ্যানেল নিশ্চিত করে। একাধিক ক্লায়েন্ট হোস্টকে একাধিক সার্ভারের সাথে একযোগে সংযোগ করতে সক্ষম করে।

**ক্লায়েন্ট** হল হোস্ট অ্যাপ্লিকেশনের মধ্যে সংযোগকারী উপাদান। তারা:

- **প্রোটোকল যোগাযোগ**: JSON-RPC 2.0 অনুরোধগুলি সার্ভারে প্রম্পট এবং নির্দেশাবলী সহ পাঠানো
- **ক্ষমতা আলোচনা**: প্রাথমিককরণের সময় সার্ভারের সাথে সমর্থিত বৈশিষ্ট্য এবং প্রোটোকল সংস্করণ আলোচনা করা
- **টুল কার্যকর করা**: মডেল থেকে টুল কার্যকর করার অনুরোধ পরিচালনা এবং প্রতিক্রিয়া প্রক্রিয়া করা
- **রিয়েল-টাইম আপডেট**: সার্ভার থেকে বিজ্ঞপ্তি এবং রিয়েল-টাইম আপডেট পরিচালনা করা
- **প্রতিক্রিয়া প্রক্রিয়াকরণ**: ব্যবহারকারীদের প্রদর্শনের জন্য সার্ভারের প্রতিক্রিয়া প্রক্রিয়া এবং ফরম্যাট করা

### 3. সার্ভার

**সার্ভার** হল প্রোগ্রাম যা MCP ক্লায়েন্টকে প্রসঙ্গ, টুল এবং ক্ষমতা প্রদান করে। তারা স্থানীয়ভাবে (হোস্টের মতো একই মেশিনে) বা দূরবর্তীভাবে (বাহ্যিক প্ল্যাটফর্মে) কার্যকর হতে পারে এবং ক্লায়েন্ট অনুরোধগুলি পরিচালনা এবং গঠিত প্রতিক্রিয়া প্রদান করার জন্য দায়ী। সার্ভারগুলি স্ট্যান্ডার্ডাইজড Model Context Protocol এর মাধ্যমে নির্দিষ্ট কার্যকারিতা প্রকাশ করে।

**সার্ভার** হল পরিষেবা যা প্রসঙ্গ এবং ক্ষমতা প্রদান করে। তারা:

- **বৈশিষ্ট্য নিবন্ধন**: উপলব্ধ প্রিমিটিভ (রিসোর্স, প্রম্পট, টুল) ক্লায়েন্টদের কাছে নিবন্ধন এবং প্রকাশ করা
- **অনুরোধ প্রক্রিয়াকরণ**: ক্লায়েন্ট থেকে টুল কল, রিসোর্স অনুরোধ এবং প্রম্পট অনুরোধ গ্রহণ এবং কার্যকর করা
- **প্রসঙ্গ প্রদান**: মডেল প্রতিক্রিয়া উন্নত করতে প্রসঙ্গগত তথ্য এবং ডেটা প্রদান করা
- **অবস্থা ব্যবস্থাপনা**: সেশন অবস্থা বজায় রাখা এবং প্রয়োজন হলে স্টেটফুল ইন্টারঅ্যাকশন পরিচালনা করা
- **রিয়েল-টাইম বিজ্ঞপ্তি**: সংযুক্ত ক্লায়েন্টদের ক্ষমতা পরিবর্তন এবং আপডেট সম্পর্কে বিজ্ঞপ্তি পাঠানো

সার্ভারগুলি যে কেউ তৈরি করতে পারে মডেল ক্ষমতা প্রসারিত করার জন্য বিশেষায়িত কার্যকারিতা সহ, এবং তারা স্থানীয় এবং দূরবর্তী উভয় স্থাপনার দৃশ্যকল্প সমর্থন করে।

### 4. সার্ভার প্রিমিটিভ

Model Context Protocol (MCP)-এ সার্ভার তিনটি মূল **প্রিমিটিভ** প্রদান করে যা ক্লায়েন্ট, হোস্ট এবং ভাষার মডেলের মধ্যে সমৃদ্ধ ইন্টারঅ্যাকশনগুলির জন্য মৌলিক বিল্ডিং ব্লক সংজ্ঞায়িত করে। এই প্রিমিটিভগুলি প্রোটোকলের মাধ্যমে উপলব্ধ প্রসঙ্গগত তথ্য এবং ক্রিয়াগুলির ধরন নির্দিষ্ট করে।

MCP সার্ভারগুলি নিম্নলিখিত তিনটি মূল প্রিমিটিভের যেকোনো সংমিশ্রণ প্রকাশ করতে পারে:

#### রিসোর্স

**রিসোর্স** হল ডেটা উৎস যা AI অ্যাপ্লিকেশনগুলিকে প্রসঙ্গগত তথ্য প্রদান করে। তারা মডেলের বোঝাপড়া এবং সিদ্ধান্ত গ্রহণ উন্নত করতে স্থির বা গতিশীল বিষয়বস্তু উপস্থাপন করে:

- **প্রসঙ্গগত ডেটা**: AI মডেল ব্যবহারের জন্য গঠিত তথ্য এবং প্রসঙ্গ
- **জ্ঞানভিত্তি**: ডকুমেন্ট রিপোজিটরি, নিবন্ধ, ম্যানুয়াল এবং গবেষণাপত্র
- **স্থানীয় ডেটা উৎস**: ফাইল, ডেটাবেস এবং স্থানীয় সিস্টেম তথ্য  
- **বাহ্যিক ডেটা**: API প্রতিক্রিয়া, ওয়েব পরিষেবা এবং দূরবর্তী সিস্টেম ডেটা
- **গতিশীল বিষয়বস্তু**: বাহ্যিক অবস্থার উপর ভিত্তি করে আপডেট হওয়া রিয়েল-টাইম ডেটা

রিসোর্সগুলি URI দ্বারা চিহ্নিত করা হয় এবং `resources/list` এর মাধ্যমে আবিষ্কার এবং `resources/read` পদ্ধতির মাধ্যমে পুনরুদ্ধার সমর্থন করে:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### প্রম্পট

**প্রম্পট** হল পুনরায় ব্যবহারযোগ্য টেমপ্লেট যা ভাষার মডেলের সাথে ইন্টারঅ্যাকশন গঠন করতে সাহায্য করে। তারা স্ট্যান্ডার্ডাইজড ইন্টারঅ্যাকশন প্যাটার্ন এবং টেমপ্লেটেড ওয়ার্কফ্লো প্রদান করে:

- **টেমপ্লেট-ভিত্তিক ইন্টারঅ্যাকশন**: পূর্ব-গঠিত বার্তা এবং কথোপকথনের সূচনা
- **ওয়ার্কফ্লো টেমপ্লেট**: সাধারণ কাজ এবং ইন্টারঅ্যাকশনের জন্য স্ট্যান্ডার্ডাইজড ক্রম
- **ফিউ-শট উদাহরণ**: মডেল নির্দেশনার জন্য উদাহরণ-ভিত্তিক টেমপ্লেট
- **সিস্টেম প্রম্পট**: মডেলের আচরণ এবং প্রসঙ্গ সংজ্ঞায়িত করার জন্য ভিত্তিমূলক প্রম্পট
- **গতিশীল টেমপ্লেট**: নির্দিষ্ট প্রসঙ্গের সাথে মানানসই প্যারামিটারযুক্ত প্রম্পট

প্রম্পটগুলি ভেরিয়েবল প্রতিস্থাপন সমর্থন করে এবং `prompts/list` এর মাধ্যমে আবিষ্কার এবং `prompts/get` এর মাধ্যমে পুনরুদ্ধার করা যায়:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### টুল

**টুল** হল কার্যকরযোগ্য ফাংশন যা AI মডেলগুলি নির্দিষ্ট ক্রিয়াকলাপ সম্পাদনের জন্য আহ্বান করতে পারে। তারা MCP ইকোসিস্টেমের "ক্রিয়াপদ" উপস্থাপন করে, মডেলগুলিকে বাহ্যিক সিস্টেমের সাথে ইন্টারঅ্যাক্ট করতে সক্ষম করে:

- **কার্যকরযোগ্য ফাংশন**: নির্দিষ্ট প্যারামিটার সহ মডেলগুলি আহ্বান করতে পারে এমন পৃথক অপারেশন
- **বাহ্যিক সিস্টেম ইন্টিগ্রেশন**: API কল, ডেটাবেস অনুসন্ধান, ফাইল অপারেশন, গণনা
- **অনন্য পরিচয়**: প্রতিটি টুলের একটি স্বতন্ত্র নাম, বিবরণ এবং প্যারামিটার স্কিমা থাকে
- **গঠিত I/O**: টুলগুলি যাচাইকৃত প্যারামিটার গ্রহণ করে এবং গঠিত, টাইপ করা প্রতিক্রিয়া প্রদান করে
- **ক্রিয়া ক্ষমতা**: মডেলগুলিকে বাস্তব-জগতের ক্রিয়া সম্পাদন এবং লাইভ ডেটা পুনরুদ্ধার করতে সক্ষম করে

টুলগুলি প্যারামিটার যাচাইকরণের জন্য JSON Schema দিয়ে সংজ্ঞায়িত করা হয় এবং `tools/list` এর মাধ্যমে আবিষ্কার এবং `tools/call` এর মাধ্যমে কার্যকর করা হয়:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## ক্লায়েন্ট প্রিমিটিভ

Model Context Protocol (MCP)-এ, **ক্লায়েন্ট** প্রিমিটিভ প্রকাশ করতে পারে যা সার্ভারগুলিকে হোস্ট অ্যাপ্লিকেশন থেকে অতিরিক্ত ক্ষমতা অনুরোধ করতে সক্ষম করে। এই ক্লায়েন্ট-সাইড প্রিমিটিভগুলি সমৃদ্ধ, আরও ইন্টারঅ্যাকটিভ সার্ভার বাস্তবায়ন সক্ষম করে যা AI মডেল ক্ষমতা এবং ব্যবহারকারীর ইন্টারঅ্যাকশন অ্যাক্সেস করতে পারে।

### স্যাম্পলিং

**স্যাম্পলিং** সার্ভারগুলিকে ক্লায়েন্টের AI অ্যাপ্লিকেশন থেকে ভাষার মডেল সম্পন্ন করার অনুরোধ করতে সক্ষম করে। এই প্রিমিটিভটি সার্ভারগুলিকে তাদের নিজস্ব মডেল নির্ভরতা এম্বেড না করে LLM ক্ষমতা অ্যাক্সেস করতে দেয়:

- **মডেল-স্বাধীন অ্যাক্সেস**: সার্ভারগুলি LLM SDK অন্তর্ভুক্ত না করে বা মডেল অ্যাক্সেস পরিচালনা না করে সম্পন্ন করার অনুরোধ করতে পারে
- **সার্ভার-প্রারম্ভিক AI**: সার্ভারগুলিকে ক্লায়েন্টের AI মডেল ব্যবহার করে স্বায়ত্তশাসিতভাবে বিষয়বস্তু তৈরি করতে সক্ষম করে
- **পুনরাবৃত্ত LLM ইন্টারঅ্যাকশন**: জটিল দৃশ্যকল্প সমর্থন করে যেখানে সার্ভারগুলিকে প্রক্রিয়াকরণের জন্য AI সহায়তা প্রয়োজন
- **গতিশীল বিষয়বস্তু তৈরি**: হোস্টের মডেল ব্যবহার করে প্রসঙ্গগত প্রতিক্রিয়া তৈরি করতে সার্ভারগুলিকে সক্ষম করে

স্যাম্পলিং `sampling/complete` পদ্ধতির মাধ্যমে শুরু হয়, যেখানে সার্ভারগুলি ক্লায়েন্টে সম্পন্ন করার অনুরোধ পাঠায়।

### এলিসিটেশন  

**এলিসিটেশন** সার্ভারগুলিকে ক্লায়েন্ট ইন্টারফেসের মাধ্যমে ব্যবহারকারীদের কাছ থেকে অতিরিক্ত তথ্য বা নিশ্চিতকরণ অনুরোধ করতে সক্ষম করে:

- **ব্যবহারকারী ইনপুট অনুরোধ**: টুল কার্যকর করার জন্য প্রয়োজন হলে সার্ভারগুলি অতিরিক্ত তথ্য চাইতে পারে
- **নিশ্চিতকরণ ডায়ালগ**: সংবেদনশীল বা প্রভাবশালী অপারেশনের জন্য ব্যবহারকারীর অনুমোদন অনুরোধ করুন
- **ইন্টারঅ্যাকটিভ ওয়ার্কফ্লো**: সার্ভারগুলিকে ধাপে ধাপে ব্যবহারকারীর ইন্টারঅ্যাকশন তৈরি করতে সক্ষম করুন
- **গতিশীল প্যারামিটার সংগ্রহ**: টুল কার্যকর করার সময় অনুপস্থিত বা ঐচ্ছিক প্যারামিটার সংগ্রহ করুন

এলিসিটেশন অনুরোধগুলি `elicitation/request` পদ্ধতি ব্যবহার করে ক্লায়েন্টের ইন্টারফেসের মাধ্যমে ব্যবহারকারীর ইনপুট সংগ্রহ করতে করা হয়।

### লগিং

**লগিং** সার্ভারগুলিকে ডিবাগিং, পর্যবেক্ষণ এবং অপারেশনাল দৃশ্যমানতার জন্য ক্লায়েন্টে গঠিত লগ বার্তা পাঠাতে সক্ষম করে:

- **ডিবাগিং সমর্থন**: সার্ভারগুলিকে ডিবাগিংয়ের জন্য বিশদ কার্যকরকরণ লগ প্রদান করতে সক্ষম করুন
- **অপারেশনাল পর্যবেক্ষণ**: ক্লায়েন্টে স্ট্যাটাস আপডেট এবং কর্মক্ষমতা মেট্রিক পাঠান
- **ত্রুটি রিপোর্টিং**: বিশদ
- **লাইফসাইকেল ম্যানেজমেন্ট**: ক্লায়েন্ট এবং সার্ভারের মধ্যে সংযোগ শুরু করা, সক্ষমতা আলোচনা করা এবং সেশন বন্ধ করার কাজ পরিচালনা করে  
- **সার্ভার প্রিমিটিভস**: সার্ভারগুলোকে টুল, রিসোর্স এবং প্রম্পটের মাধ্যমে মূল কার্যকারিতা প্রদান করতে সক্ষম করে  
- **ক্লায়েন্ট প্রিমিটিভস**: সার্ভারগুলোকে LLM থেকে স্যাম্পলিং অনুরোধ করা, ব্যবহারকারীর ইনপুট সংগ্রহ করা এবং লগ বার্তা পাঠানোর সুযোগ দেয়  
- **রিয়েল-টাইম নোটিফিকেশন**: পোলিং ছাড়াই গতিশীল আপডেটের জন্য অ্যাসিঙ্ক্রোনাস নোটিফিকেশন সমর্থন করে  

#### প্রধান বৈশিষ্ট্যসমূহ:

- **প্রোটোকল ভার্সন আলোচনা**: সামঞ্জস্য নিশ্চিত করতে তারিখ-ভিত্তিক ভার্সনিং (YYYY-MM-DD) ব্যবহার করে  
- **সক্ষমতা আবিষ্কার**: ক্লায়েন্ট এবং সার্ভারগুলো প্রাথমিক সংযোগের সময় সমর্থিত বৈশিষ্ট্যের তথ্য বিনিময় করে  
- **স্টেটফুল সেশন**: প্রসঙ্গের ধারাবাহিকতা বজায় রাখতে একাধিক ইন্টারঅ্যাকশনের মধ্যে সংযোগের অবস্থা ধরে রাখে  

### ট্রান্সপোর্ট লেয়ার

**ট্রান্সপোর্ট লেয়ার** MCP অংশগ্রহণকারীদের মধ্যে যোগাযোগ চ্যানেল, বার্তা ফ্রেমিং এবং প্রমাণীকরণ পরিচালনা করে:

#### সমর্থিত ট্রান্সপোর্ট পদ্ধতি:

1. **STDIO ট্রান্সপোর্ট**:
   - সরাসরি প্রসেস যোগাযোগের জন্য স্ট্যান্ডার্ড ইনপুট/আউটপুট স্ট্রিম ব্যবহার করে  
   - একই মেশিনে স্থানীয় প্রসেসের জন্য উপযুক্ত, যেখানে নেটওয়ার্ক ওভারহেড নেই  
   - সাধারণত স্থানীয় MCP সার্ভার ইমপ্লিমেন্টেশনের জন্য ব্যবহৃত হয়  

2. **স্ট্রিমেবল HTTP ট্রান্সপোর্ট**:
   - ক্লায়েন্ট-টু-সার্ভার বার্তার জন্য HTTP POST ব্যবহার করে  
   - সার্ভার-টু-ক্লায়েন্ট স্ট্রিমিংয়ের জন্য ঐচ্ছিক Server-Sent Events (SSE)  
   - নেটওয়ার্কের মাধ্যমে দূরবর্তী সার্ভার যোগাযোগ সক্ষম করে  
   - স্ট্যান্ডার্ড HTTP প্রমাণীকরণ সমর্থন করে (বিয়ারার টোকেন, API কী, কাস্টম হেডার)  
   - MCP নিরাপদ টোকেন-ভিত্তিক প্রমাণীকরণের জন্য OAuth সুপারিশ করে  

#### ট্রান্সপোর্ট অ্যাবস্ট্রাকশন:

ট্রান্সপোর্ট লেয়ার ডেটা লেয়ার থেকে যোগাযোগের বিবরণকে পৃথক করে, সমস্ত ট্রান্সপোর্ট পদ্ধতির জন্য একই JSON-RPC 2.0 বার্তা ফরম্যাট সক্ষম করে। এই অ্যাবস্ট্রাকশন অ্যাপ্লিকেশনগুলোকে স্থানীয় এবং দূরবর্তী সার্ভারের মধ্যে নির্বিঘ্নে স্যুইচ করতে দেয়।

### নিরাপত্তা বিবেচনা

MCP ইমপ্লিমেন্টেশনগুলোকে নিরাপদ, বিশ্বাসযোগ্য এবং সুরক্ষিত ইন্টারঅ্যাকশন নিশ্চিত করতে কয়েকটি গুরুত্বপূর্ণ নিরাপত্তা নীতির অনুসরণ করতে হবে:

- **ব্যবহারকারীর সম্মতি এবং নিয়ন্ত্রণ**: কোনো ডেটা অ্যাক্সেস বা অপারেশন সম্পাদনের আগে ব্যবহারকারীদের স্পষ্ট সম্মতি প্রদান করতে হবে। তারা কী ডেটা শেয়ার করা হচ্ছে এবং কোন কার্যক্রম অনুমোদিত তা স্পষ্টভাবে নিয়ন্ত্রণ করতে পারবে, যা সহজবোধ্য ব্যবহারকারী ইন্টারফেসের মাধ্যমে কার্যক্রম পর্যালোচনা এবং অনুমোদনের সুযোগ দেয়।  

- **ডেটা গোপনীয়তা**: ব্যবহারকারীর ডেটা শুধুমাত্র স্পষ্ট সম্মতির মাধ্যমে প্রকাশ করা উচিত এবং যথাযথ অ্যাক্সেস নিয়ন্ত্রণ দ্বারা সুরক্ষিত থাকতে হবে। MCP ইমপ্লিমেন্টেশনগুলোকে অননুমোদিত ডেটা ট্রান্সমিশন থেকে রক্ষা করতে হবে এবং সমস্ত ইন্টারঅ্যাকশনের সময় গোপনীয়তা বজায় রাখতে হবে।  

- **টুল নিরাপত্তা**: কোনো টুল চালানোর আগে স্পষ্ট ব্যবহারকারীর সম্মতি প্রয়োজন। ব্যবহারকারীদের প্রতিটি টুলের কার্যকারিতা সম্পর্কে পরিষ্কার ধারণা থাকতে হবে এবং অনিচ্ছাকৃত বা অনিরাপদ টুল কার্যক্রম প্রতিরোধ করতে শক্তিশালী নিরাপত্তা সীমা প্রয়োগ করতে হবে।  

এই নিরাপত্তা নীতিগুলো অনুসরণ করে MCP ব্যবহারকারীর বিশ্বাস, গোপনীয়তা এবং নিরাপত্তা বজায় রাখে, একই সাথে শক্তিশালী AI ইন্টিগ্রেশন সক্ষম করে।

## কোড উদাহরণ: প্রধান উপাদানসমূহ

নিচে বিভিন্ন জনপ্রিয় প্রোগ্রামিং ভাষায় কোড উদাহরণ দেওয়া হয়েছে, যা কীভাবে MCP সার্ভার উপাদান এবং টুলগুলো ইমপ্লিমেন্ট করতে হয় তা প্রদর্শন করে।

### .NET উদাহরণ: টুলসহ একটি সাধারণ MCP সার্ভার তৈরি করা

এখানে একটি ব্যবহারিক .NET কোড উদাহরণ দেওয়া হয়েছে, যা কাস্টম টুল সহ একটি সাধারণ MCP সার্ভার ইমপ্লিমেন্ট করার পদ্ধতি প্রদর্শন করে। এই উদাহরণটি টুল সংজ্ঞায়িত এবং নিবন্ধন করা, অনুরোধ পরিচালনা করা এবং Model Context Protocol ব্যবহার করে সার্ভার সংযোগ করার পদ্ধতি দেখায়।

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### জাভা উদাহরণ: MCP সার্ভার উপাদানসমূহ

এই উদাহরণটি উপরের .NET উদাহরণের মতো একই MCP সার্ভার এবং টুল নিবন্ধন প্রদর্শন করে, তবে এটি জাভাতে ইমপ্লিমেন্ট করা হয়েছে।

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### পাইথন উদাহরণ: MCP সার্ভার তৈরি করা

এই উদাহরণে দেখানো হয়েছে কীভাবে পাইথনে একটি MCP সার্ভার তৈরি করতে হয়। এখানে দুটি ভিন্ন পদ্ধতিতে টুল তৈরি করার পদ্ধতিও দেখানো হয়েছে।

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### জাভাস্ক্রিপ্ট উদাহরণ: MCP সার্ভার তৈরি করা

এই উদাহরণটি জাভাস্ক্রিপ্টে MCP সার্ভার তৈরি এবং দুটি আবহাওয়া-সম্পর্কিত টুল নিবন্ধনের পদ্ধতি দেখায়।

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

এই জাভাস্ক্রিপ্ট উদাহরণটি দেখায় কীভাবে একটি MCP ক্লায়েন্ট তৈরি করতে হয়, যা একটি সার্ভারের সাথে সংযোগ স্থাপন করে, একটি প্রম্পট পাঠায় এবং টুল কলসহ প্রতিক্রিয়া প্রক্রিয়া করে।

## নিরাপত্তা এবং অনুমোদন

MCP প্রোটোকলের মাধ্যমে নিরাপত্তা এবং অনুমোদন পরিচালনার জন্য কয়েকটি অন্তর্নির্মিত ধারণা এবং পদ্ধতি অন্তর্ভুক্ত করে:

1. **টুল অনুমতি নিয়ন্ত্রণ**:  
   ক্লায়েন্টগুলো নির্দিষ্ট করতে পারে কোন টুলগুলো একটি মডেল সেশনের সময় ব্যবহার করতে পারবে। এটি নিশ্চিত করে যে শুধুমাত্র স্পষ্টভাবে অনুমোদিত টুলগুলো অ্যাক্সেসযোগ্য, যা অনিচ্ছাকৃত বা অনিরাপদ কার্যক্রমের ঝুঁকি কমায়। অনুমতিগুলো ব্যবহারকারীর পছন্দ, সংস্থার নীতি বা ইন্টারঅ্যাকশনের প্রসঙ্গ অনুযায়ী গতিশীলভাবে কনফিগার করা যেতে পারে।  

2. **প্রমাণীকরণ**:  
   টুল, রিসোর্স বা সংবেদনশীল কার্যক্রমে অ্যাক্সেস দেওয়ার আগে সার্ভারগুলো প্রমাণীকরণ প্রয়োজন করতে পারে। এটি API কী, OAuth টোকেন বা অন্যান্য প্রমাণীকরণ স্কিমের মাধ্যমে হতে পারে। সঠিক প্রমাণীকরণ নিশ্চিত করে যে শুধুমাত্র বিশ্বাসযোগ্য ক্লায়েন্ট এবং ব্যবহারকারীরা সার্ভার-সাইড সক্ষমতা ব্যবহার করতে পারে।  

3. **ভ্যালিডেশন**:  
   সমস্ত টুল কলের জন্য প্যারামিটার ভ্যালিডেশন প্রয়োগ করা হয়। প্রতিটি টুল তার প্যারামিটারগুলোর জন্য প্রত্যাশিত টাইপ, ফরম্যাট এবং সীমাবদ্ধতা সংজ্ঞায়িত করে, এবং সার্ভার অনুযায়ী আসা অনুরোধগুলো যাচাই করে। এটি টুল ইমপ্লিমেন্টেশনে ত্রুটিপূর্ণ বা ক্ষতিকারক ইনপুট পৌঁছানো থেকে রক্ষা করে এবং কার্যক্রমের অখণ্ডতা বজায় রাখতে সাহায্য করে।  

4. **রেট লিমিটিং**:  
   সার্ভার রিসোর্সের অপব্যবহার প্রতিরোধ এবং ন্যায্য ব্যবহার নিশ্চিত করতে MCP সার্ভারগুলো টুল কল এবং রিসোর্স অ্যাক্সেসের জন্য রেট লিমিটিং ইমপ্লিমেন্ট করতে পারে। রেট লিমিট ব্যবহারকারী, সেশন বা গ্লোবাল ভিত্তিতে প্রয়োগ করা যেতে পারে এবং ডিনায়াল-অফ-সার্ভিস আক্রমণ বা অতিরিক্ত রিসোর্স ব্যবহারের বিরুদ্ধে সুরক্ষা প্রদান করে।  

এই পদ্ধতিগুলো একত্রিত করে MCP ভাষার মডেলগুলোকে বাইরের টুল এবং ডেটা সোর্সের সাথে সংযুক্ত করার জন্য একটি নিরাপদ ভিত্তি প্রদান করে, একই সাথে ব্যবহারকারী এবং ডেভেলপারদের অ্যাক্সেস এবং ব্যবহারের উপর সূক্ষ্ম নিয়ন্ত্রণ দেয়।

## প্রোটোকল বার্তা এবং যোগাযোগ প্রবাহ

MCP যোগাযোগ **JSON-RPC 2.0** বার্তা ব্যবহার করে হোস্ট, ক্লায়েন্ট এবং সার্ভারের মধ্যে পরিষ্কার এবং নির্ভরযোগ্য ইন্টারঅ্যাকশন সহজতর করে। প্রোটোকল বিভিন্ন ধরনের অপারেশনের জন্য নির্দিষ্ট বার্তা প্যাটার্ন সংজ্ঞায়িত করে:

### মূল বার্তা প্রকার:

#### **ইনিশিয়ালাইজেশন বার্তা**
- **`initialize` অনুরোধ**: সংযোগ স্থাপন করে এবং প্রোটোকল ভার্সন এবং সক্ষমতা আলোচনা করে  
- **`initialize` প্রতিক্রিয়া**: সমর্থিত বৈশিষ্ট্য এবং সার্ভার তথ্য নিশ্চিত করে  
- **`notifications/initialized`**: ইঙ্গিত দেয় যে ইনিশিয়ালাইজেশন সম্পন্ন হয়েছে এবং সেশন প্রস্তুত  

#### **আবিষ্কার বার্তা**
- **`tools/list` অনুরোধ**: সার্ভার থেকে উপলব্ধ টুলগুলো আবিষ্কার করে  
- **`resources/list` অনুরোধ**: উপলব্ধ রিসোর্স (ডেটা সোর্স) তালিকাভুক্ত করে  
- **`prompts/list` অনুরোধ**: উপলব্ধ প্রম্পট টেমপ্লেটগুলো পুনরুদ্ধার করে  

#### **কার্যকরী বার্তা**  
- **`tools/call` অনুরোধ**: প্রদত্ত প্যারামিটার সহ একটি নির্দিষ্ট টুল কার্যকর করে  
- **`resources/read` অনুরোধ**: একটি নির্দিষ্ট রিসোর্স থেকে বিষয়বস্তু পুনরুদ্ধার করে  
- **`prompts/get` অনুরোধ**: ঐচ্ছিক প্যারামিটার সহ একটি প্রম্পট টেমপ্লেট পুনরুদ্ধার করে  

#### **ক্লায়েন্ট-সাইড বার্তা**
- **`sampling/complete` অনুরোধ**: সার্ভার ক্লায়েন্ট থেকে LLM সম্পূর্ণতা অনুরোধ করে  
- **`elicitation/request`**: সার্ভার ক্লায়েন্ট ইন্টারফেসের মাধ্যমে ব্যবহারকারীর ইনপুট অনুরোধ করে  
- **লগিং বার্তা**: সার্ভার ক্লায়েন্টকে কাঠামোগত লগ বার্তা পাঠায়  

#### **নোটিফিকেশন বার্তা**
- **`notifications/tools/list_changed`**: সার্ভার ক্লায়েন্টকে টুল পরিবর্তনের বিষয়ে জানায়  
- **`notifications/resources/list_changed`**: সার্ভার ক্লায়েন্টকে রিসোর্স পরিবর্তনের বিষয়ে জানায়  
- **`notifications/prompts/list_changed`**: সার্ভার ক্লায়েন্টকে প্রম্পট পরিবর্তনের বিষয়ে জানায়  

### বার্তা কাঠামো:

সমস্ত MCP বার্তা JSON-RPC 2.0 ফরম্যাট অনুসরণ করে:
- **অনুরোধ বার্তা**: `id`, `method` এবং ঐচ্ছিক `params` অন্তর্ভুক্ত করে  
- **প্রতিক্রিয়া বার্তা**: `id` এবং `result` বা `error` অন্তর্ভুক্ত করে  
- **নোটিফিকেশন বার্তা**: `method` এবং ঐচ্ছিক `params` অন্তর্ভুক্ত করে (কোনো `id` বা প্রতিক্রিয়া প্রত্যাশিত নয়)  

এই কাঠামোগত যোগাযোগ নির্ভরযোগ্য, ট্রেসযোগ্য এবং এক্সটেনসিবল ইন্টারঅ্যাকশন নিশ্চিত করে, যা রিয়েল-টাইম আপডেট, টুল চেইনিং এবং শক্তিশালী ত্রুটি পরিচালনার মতো উন্নত পরিস্থিতি সমর্থন করে।

## প্রধান বিষয়গুলো

- **আর্কিটেকচার**: MCP একটি ক্লায়েন্ট-সার্ভার আর্কিটেকচার ব্যবহার করে যেখানে হোস্টগুলো একাধিক ক্লায়েন্ট সংযোগ পরিচালনা করে  
- **অংশগ্রহণকারীরা**: ইকোসিস্টেমে হোস্ট (AI অ্যাপ্লিকেশন), ক্লায়েন্ট (প্রোটোকল সংযোগকারী) এবং সার্ভার (সক্ষমতা প্রদানকারী) অন্তর্ভুক্ত  
- **ট্রান্সপোর্ট পদ্ধতি**: যোগাযোগ STDIO (স্থানীয়) এবং Streamable HTTP সহ ঐচ্ছিক SSE (দূরবর্তী) সমর্থন করে  
- **মূল প্রিমিটিভস**: সার্ভারগুলো টুল (কার্যকরী ফাংশন), রিসোর্স (ডেটা সোর্স) এবং প্রম্পট (টেমপ্লেট) প্রকাশ করে  
- **ক্লায়েন্ট প্রিমিটিভস**: সার্ভারগুলো ক্লায়েন্ট থেকে স্যাম্পলিং (LLM সম্পূর্ণতা), এলিসিটেশন (ব্যবহারকারীর ইনপুট) এবং লগিং অনুরোধ করতে পারে  
- **প্রোটোকল ভিত্তি**: JSON-RPC 2.0 এর উপর নির্মিত, তারিখ-ভিত্তিক ভার্সনিং সহ (বর্তমান: 2025-06-18)  
- **রিয়েল-টাইম সক্ষমতা**: গতিশীল আপডেট এবং রিয়েল-টাইম সিঙ্ক্রোনাইজেশনের জন্য নোটিফিকেশন সমর্থন করে  
- **নিরাপত্তা প্রথম**: স্পষ্ট ব্যবহারকারীর সম্মতি, ডেটা গোপনীয়তা সুরক্ষা এবং নিরাপদ ট্রান্সপোর্ট প্রধান প্রয়োজনীয়তা  

## অনুশীলন

আপনার ডোমেইনে একটি সাধারণ MCP টুল ডিজাইন করুন। সংজ্ঞায়িত করুন:
1. টুলটির নাম কী হবে  
2. এটি কোন প্যারামিটার গ্রহণ করবে  
3. এটি কী আউটপুট প্রদান করবে  
4. একটি মডেল কীভাবে এই টুলটি ব্যবহার করে ব্যবহারকারীর সমস্যার সমাধান করতে পারে  

---

## পরবর্তী ধাপ

পরবর্তী: [চ্যাপ্টার ২: নিরাপত্তা](../02-Security/README.md)

**অস্বীকৃতি**:  
এই নথিটি AI অনুবাদ পরিষেবা [Co-op Translator](https://github.com/Azure/co-op-translator) ব্যবহার করে অনুবাদ করা হয়েছে। আমরা যথাসাধ্য সঠিকতা নিশ্চিত করার চেষ্টা করি, তবে অনুগ্রহ করে মনে রাখবেন যে স্বয়ংক্রিয় অনুবাদে ত্রুটি বা অসঙ্গতি থাকতে পারে। মূল ভাষায় থাকা নথিটিকে প্রামাণিক উৎস হিসেবে বিবেচনা করা উচিত। গুরুত্বপূর্ণ তথ্যের জন্য, পেশাদার মানব অনুবাদ সুপারিশ করা হয়। এই অনুবাদ ব্যবহারের ফলে কোনো ভুল বোঝাবুঝি বা ভুল ব্যাখ্যা হলে আমরা দায়বদ্ধ থাকব না।