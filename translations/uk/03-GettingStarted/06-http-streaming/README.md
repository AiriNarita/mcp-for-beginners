<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T23:05:03+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "uk"
}
-->
# HTTPS Стримінг з протоколом Model Context Protocol (MCP)

Цей розділ надає детальний посібник з впровадження безпечного, масштабованого та реального часу стримінгу з використанням протоколу Model Context Protocol (MCP) через HTTPS. Він охоплює мотивацію для стримінгу, доступні механізми транспорту, як реалізувати стримінг HTTP у MCP, найкращі практики безпеки, міграцію з SSE та практичні рекомендації для створення власних стримінгових додатків MCP.

## Механізми транспорту та стримінг у MCP

Цей розділ досліджує різні механізми транспорту, доступні в MCP, та їх роль у забезпеченні можливостей стримінгу для реального часу комунікації між клієнтами та серверами.

### Що таке механізм транспорту?

Механізм транспорту визначає, як дані обмінюються між клієнтом і сервером. MCP підтримує кілька типів транспорту для задоволення різних середовищ і вимог:

- **stdio**: Стандартний ввід/вивід, підходить для локальних та CLI-інструментів. Простий, але не підходить для вебу чи хмари.
- **SSE (Server-Sent Events)**: Дозволяє серверам надсилати оновлення в реальному часі клієнтам через HTTP. Добре підходить для веб-інтерфейсів, але має обмеження у масштабованості та гнучкості.
- **Streamable HTTP**: Сучасний стримінговий транспорт на основі HTTP, підтримує сповіщення та кращу масштабованість. Рекомендується для більшості виробничих і хмарних сценаріїв.

### Таблиця порівняння

Ознайомтеся з таблицею порівняння нижче, щоб зрозуміти різницю між цими механізмами транспорту:

| Транспорт         | Оновлення в реальному часі | Стримінг | Масштабованість | Сценарій використання       |
|-------------------|---------------------------|----------|-----------------|-----------------------------|
| stdio             | Ні                        | Ні       | Низька          | Локальні CLI-інструменти    |
| SSE               | Так                       | Так      | Середня         | Веб, оновлення в реальному часі |
| Streamable HTTP   | Так                       | Так      | Висока          | Хмара, багатоклієнтські додатки |

> **Порада:** Вибір правильного транспорту впливає на продуктивність, масштабованість та досвід користувача. **Streamable HTTP** рекомендується для сучасних, масштабованих та готових до хмари додатків.

Зверніть увагу на транспорти stdio та SSE, які були розглянуті у попередніх розділах, і як Streamable HTTP є транспортом, що розглядається у цьому розділі.

## Стримінг: Концепції та мотивація

Розуміння основних концепцій та мотивації стримінгу є важливим для впровадження ефективних систем комунікації в реальному часі.

**Стримінг** — це техніка в мережевому програмуванні, яка дозволяє надсилати та отримувати дані невеликими, керованими частинами або як послідовність подій, а не чекати, поки весь відповідь буде готовий. Це особливо корисно для:

- Великих файлів або наборів даних.
- Оновлень у реальному часі (наприклад, чат, індикатори прогресу).
- Тривалих обчислень, де потрібно інформувати користувача про хід виконання.

Ось що потрібно знати про стримінг на високому рівні:

- Дані доставляються поступово, а не всі одразу.
- Клієнт може обробляти дані по мірі їх надходження.
- Зменшує сприйняту затримку та покращує досвід користувача.

### Чому використовувати стримінг?

Причини використання стримінгу наступні:

- Користувачі отримують зворотний зв'язок негайно, а не лише в кінці.
- Дозволяє створювати додатки в реальному часі та чуйні інтерфейси.
- Більш ефективне використання мережевих та обчислювальних ресурсів.

### Простий приклад: HTTP стримінговий сервер і клієнт

Ось простий приклад того, як можна реалізувати стримінг:

#### Python

**Сервер (Python, використовуючи FastAPI та StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**Клієнт (Python, використовуючи requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

Цей приклад демонструє сервер, який надсилає серію повідомлень клієнту по мірі їх готовності, а не чекає, поки всі повідомлення будуть готові.

**Як це працює:**

- Сервер передає кожне повідомлення по мірі його готовності.
- Клієнт отримує та друкує кожен шматок по мірі його надходження.

**Вимоги:**

- Сервер повинен використовувати стримінгову відповідь (наприклад, `StreamingResponse` у FastAPI).
- Клієнт повинен обробляти відповідь як стримінг (`stream=True` у requests).
- Content-Type зазвичай `text/event-stream` або `application/octet-stream`.

#### Java

**Сервер (Java, використовуючи Spring Boot та Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Клієнт (Java, використовуючи Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Примітки щодо реалізації в Java:**

- Використовує реактивний стек Spring Boot з `Flux` для стримінгу.
- `ServerSentEvent` забезпечує структурований стримінг подій з типами подій.
- `WebClient` з `bodyToFlux()` дозволяє реактивне споживання стримінгу.
- `delayElements()` імітує час обробки між подіями.
- Події можуть мати типи (`info`, `result`) для кращої обробки клієнтом.

### Порівняння: Класичний стримінг vs MCP стримінг

Різниця між тим, як стримінг працює у "класичному" вигляді, і тим, як він працює у MCP, може бути представлена так:

| Особливість            | Класичний HTTP стримінг       | MCP стримінг (сповіщення)          |
|------------------------|------------------------------|------------------------------------|
| Основна відповідь      | Частинами                   | Єдина, в кінці                    |
| Оновлення прогресу     | Надсилаються як частини даних | Надсилаються як сповіщення         |
| Вимоги до клієнта      | Повинен обробляти стримінг   | Повинен реалізувати обробник повідомлень |
| Сценарій використання  | Великі файли, AI токени      | Прогрес, логи, зворотний зв'язок у реальному часі |

### Спостережувані ключові відмінності

Додатково, ось деякі ключові відмінності:

- **Шаблон комунікації:**
  - Класичний HTTP стримінг: Використовує просте кодування передачі частинами для надсилання даних.
  - MCP стримінг: Використовує структуровану систему сповіщень з протоколом JSON-RPC.

- **Формат повідомлень:**
  - Класичний HTTP: Простий текст частинами з новими рядками.
  - MCP: Структуровані об'єкти LoggingMessageNotification з метаданими.

- **Реалізація клієнта:**
  - Класичний HTTP: Простий клієнт, який обробляє стримінгові відповіді.
  - MCP: Більш складний клієнт з обробником повідомлень для обробки різних типів повідомлень.

- **Оновлення прогресу:**
  - Класичний HTTP: Прогрес є частиною основного стримінгу відповіді.
  - MCP: Прогрес надсилається через окремі повідомлення про сповіщення, тоді як основна відповідь надходить в кінці.

### Рекомендації

Ось кілька рекомендацій щодо вибору між реалізацією класичного стримінгу (як кінцевої точки, яку ми показали вище, використовуючи `/stream`) та вибором стримінгу через MCP.

- **Для простих потреб стримінгу:** Класичний HTTP стримінг простіший у реалізації та достатній для базових потреб стримінгу.

- **Для складних, інтерактивних додатків:** MCP стримінг забезпечує більш структурований підхід з багатшими метаданими та розділенням між сповіщеннями та кінцевими результатами.

- **Для AI-додатків:** Система сповіщень MCP особливо корисна для тривалих AI-завдань, де потрібно інформувати користувачів про хід виконання.

## Стримінг у MCP

Отже, ви вже бачили деякі рекомендації та порівняння щодо різниці між класичним стримінгом та стримінгом у MCP. Давайте детально розглянемо, як саме можна використовувати стримінг у MCP.

Розуміння того, як стримінг працює в рамках MCP, є важливим для створення чуйних додатків, які забезпечують зворотний зв'язок у реальному часі для користувачів під час тривалих операцій.

У MCP стримінг не стосується надсилання основної відповіді частинами, а стосується надсилання **сповіщень** клієнту під час обробки запиту інструментом. Ці сповіщення можуть включати оновлення прогресу, логи або інші події.

### Як це працює

Основний результат все ще надсилається як єдина відповідь. Однак сповіщення можуть надсилатися як окремі повідомлення під час обробки, тим самим оновлюючи клієнта в реальному часі. Клієнт повинен бути здатним обробляти та відображати ці сповіщення.

## Що таке сповіщення?

Ми сказали "сповіщення", що це означає в контексті MCP?

Сповіщення — це повідомлення, яке надсилається сервером клієнту для інформування про прогрес, статус або інші події під час тривалої операції. Сповіщення покращують прозорість та досвід користувача.

Наприклад, клієнт повинен надіслати сповіщення після того, як початкове рукостискання з сервером було виконано.

Сповіщення виглядає як JSON-повідомлення:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

Сповіщення належать до теми в MCP, яка називається ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging).

Щоб увімкнути логування, сервер повинен активувати його як функцію/можливість, наприклад:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> Залежно від використаного SDK, логування може бути увімкнено за замовчуванням, або вам може знадобитися явно увімкнути його в конфігурації сервера.

Існують різні типи сповіщень:

| Рівень     | Опис                          | Приклад використання            |
|------------|-------------------------------|---------------------------------|
| debug      | Детальна інформація для налагодження | Точки входу/виходу функцій      |
| info       | Загальні інформаційні повідомлення | Оновлення прогресу операції     |
| notice     | Нормальні, але значні події   | Зміни конфігурації              |
| warning    | Умови попередження            | Використання застарілих функцій |
| error      | Умови помилок                 | Збої операцій                   |
| critical   | Критичні умови                | Збої компонентів системи        |
| alert      | Необхідно негайно вжити заходів | Виявлено пошкодження даних      |
| emergency  | Система не працює             | Повний збій системи             |

## Реалізація сповіщень у MCP

Щоб реалізувати сповіщення в MCP, потрібно налаштувати як серверну, так і клієнтську сторони для обробки оновлень у реальному часі. Це дозволяє вашому додатку надавати негайний зворотний зв'язок користувачам під час тривалих операцій.

### Серверна сторона: Надсилання сповіщень

Почнемо з серверної сторони. У MCP ви визначаєте інструменти, які можуть надсилати сповіщення під час обробки запитів. Сервер використовує об'єкт контексту (зазвичай `ctx`) для надсилання повідомлень клієнту.

#### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

У наведеному прикладі інструмент `process_files` надсилає три сповіщення клієнту під час обробки кожного файлу. Метод `ctx.info()` використовується для надсилання інформаційних повідомлень.

Додатково, щоб увімкнути сповіщення, переконайтеся, що ваш сервер використовує стримінговий транспорт (наприклад, `streamable-http`), а ваш клієнт реалізує обробник повідомлень для обробки сповіщень. Ось як можна налаштувати сервер для використання транспорту `streamable-http`:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

У цьому прикладі для .NET інструмент `ProcessFiles` позначений атрибутом `Tool` і надсилає три сповіщення клієнту під час обробки кожного файлу. Метод `ctx.Info()` використовується для надсилання інформаційних повідомлень.

Щоб увімкнути сповіщення у вашому сервері MCP для .NET, переконайтеся, що ви використовуєте стримінговий транспорт:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### Клієнтська сторона: Отримання сповіщень

Клієнт повинен реалізувати обробник повідомлень для обробки та відображення сповіщень по мірі їх надходження.

#### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

У наведеному коді функція `message_handler` перевіряє, чи є вхідне повідомлення сповіщенням. Якщо так, вона друкує сповіщення; якщо ні, обробляє його як звичайне серверне повідомлення. Також зверніть увагу, як `ClientSession` ініціалізується з `message_handler` для обробки вхідних сповіщень.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

У цьому прикладі для .NET функція `MessageHandler` перевіряє, чи є вхідне повідомлення сповіщенням. Якщо так, вона друкує сповіщення; якщо ні, обробляє його як звичайне серверне повідомлення. `ClientSession` ініціалізується з обробником повідомлень через `ClientSessionOptions`.

Щоб увімкнути сповіщення, переконайтеся, що ваш сервер використовує стримінговий транспорт (наприклад, `streamable-http`), а ваш клієнт реалізує обробник повідомлень для обробки сповіщень.

## Сповіщення про прогрес та сценарії

Цей розділ пояснює концепцію сповіщень про прогрес у MCP, чому вони важливі, та як їх реалізувати за допомогою Streamable HTTP. Ви також знайдете практичне завдання для закріплення вашого розуміння.

Сповіщення про прогрес — це повідомлення в реальному часі, які надсилаються сервером клієнту під час тривалих операцій. Замість того, щоб чекати завершення всього процесу, сервер інформує клієнта про поточний статус. Це покращує прозорість, досвід користувача та спрощує налагодження.

**Приклад:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### Чому використовувати сповіщення про прогрес?

Сповіщення про прогрес важливі з кількох причин:

- **Кращий досвід користувача:** Користувачі бачать оновлення по мірі виконання роботи, а не лише в кінці.
- **Зворотний зв'язок у реальному часі:** Клієнти можуть відображати індикатори прогресу або логи, роблячи додаток більш чуйним.
- **Спрощене налагодження та моніторинг:** Розробники та користувачі можуть бачити, де процес може бути повільним або застряглим.

### Як реалізувати сповіщення про прогрес

Ось як можна реалізувати сповіщення про прогрес у MCP:

- **На сервер
Є дві вагомі причини для переходу з SSE на Streamable HTTP:

- Streamable HTTP забезпечує кращу масштабованість, сумісність і розширену підтримку сповіщень у порівнянні з SSE.
- Це рекомендований транспорт для нових MCP-додатків.

### Кроки міграції

Ось як можна перейти з SSE на Streamable HTTP у ваших MCP-додатках:

- **Оновіть серверний код**, використовуючи `transport="streamable-http"` у `mcp.run()`.
- **Оновіть клієнтський код**, використовуючи `streamablehttp_client` замість SSE-клієнта.
- **Реалізуйте обробник повідомлень** у клієнті для обробки сповіщень.
- **Перевірте сумісність** з існуючими інструментами та робочими процесами.

### Підтримка сумісності

Рекомендується підтримувати сумісність з існуючими SSE-клієнтами під час процесу міграції. Ось кілька стратегій:

- Ви можете підтримувати як SSE, так і Streamable HTTP, використовуючи різні кінцеві точки для кожного транспорту.
- Поступово переводьте клієнтів на новий транспорт.

### Виклики

Переконайтеся, що ви врахували наступні виклики під час міграції:

- Оновлення всіх клієнтів
- Обробка відмінностей у доставці сповіщень

## Міркування щодо безпеки

Безпека повинна бути головним пріоритетом при реалізації будь-якого сервера, особливо при використанні HTTP-транспортів, таких як Streamable HTTP у MCP.

При реалізації MCP-серверів з HTTP-транспортами безпека стає критично важливою і вимагає ретельної уваги до різних векторів атак і механізмів захисту.

### Огляд

Безпека є ключовою при відкритті MCP-серверів через HTTP. Streamable HTTP відкриває нові поверхні для атак і вимагає ретельної конфігурації.

Ось основні міркування щодо безпеки:

- **Перевірка заголовка Origin**: Завжди перевіряйте заголовок `Origin`, щоб запобігти атакам DNS rebinding.
- **Прив’язка до localhost**: Для локальної розробки прив’язуйте сервери до `localhost`, щоб уникнути їх відкриття для загального доступу в інтернеті.
- **Аутентифікація**: Реалізуйте аутентифікацію (наприклад, API-ключі, OAuth) для розгортання у виробничому середовищі.
- **CORS**: Налаштуйте політики Cross-Origin Resource Sharing (CORS), щоб обмежити доступ.
- **HTTPS**: Використовуйте HTTPS у виробничому середовищі для шифрування трафіку.

### Найкращі практики

Крім того, ось кілька найкращих практик для забезпечення безпеки вашого MCP-сервера потокової передачі:

- Ніколи не довіряйте вхідним запитам без перевірки.
- Логуйте та відстежуйте всі доступи та помилки.
- Регулярно оновлюйте залежності для усунення вразливостей безпеки.

### Виклики

Ви зіткнетеся з деякими викликами при реалізації безпеки в MCP-серверах потокової передачі:

- Балансування між безпекою та зручністю розробки
- Забезпечення сумісності з різними клієнтськими середовищами

### Завдання: Створіть власний потоковий MCP-додаток

**Сценарій:**
Створіть MCP-сервер і клієнт, де сервер обробляє список елементів (наприклад, файлів або документів) і надсилає сповіщення для кожного обробленого елемента. Клієнт повинен відображати кожне сповіщення в режимі реального часу.

**Кроки:**

1. Реалізуйте серверний інструмент, який обробляє список і надсилає сповіщення для кожного елемента.
2. Реалізуйте клієнт з обробником повідомлень для відображення сповіщень у режимі реального часу.
3. Перевірте вашу реалізацію, запустивши сервер і клієнт, і спостерігайте за сповіщеннями.

[Рішення](./solution/README.md)

## Додаткові матеріали та подальші кроки

Щоб продовжити вивчення MCP-потоків і розширити свої знання, цей розділ пропонує додаткові ресурси та рекомендації для створення більш складних додатків.

### Додаткові матеріали

- [Microsoft: Вступ до HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS у ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Потокові запити](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Подальші кроки

- Спробуйте створити більш складні MCP-інструменти, які використовують потокову передачу для аналітики в реальному часі, чату або спільного редагування.
- Досліджуйте інтеграцію MCP-потоків із фронтенд-фреймворками (React, Vue тощо) для оновлення інтерфейсу в реальному часі.
- Далі: [Використання AI Toolkit для VSCode](../07-aitk/README.md)

**Відмова від відповідальності**:  
Цей документ було перекладено за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, зверніть увагу, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ мовою оригіналу слід вважати авторитетним джерелом. Для критично важливої інформації рекомендується професійний переклад людиною. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникли внаслідок використання цього перекладу.