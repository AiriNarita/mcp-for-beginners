<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T18:26:26+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "uk"
}
-->
# HTTPS Streaming з протоколом Model Context Protocol (MCP)

Цей розділ надає детальний посібник з впровадження безпечного, масштабованого та реального часу стрімінгу за допомогою протоколу Model Context Protocol (MCP) через HTTPS. Він охоплює мотивацію для стрімінгу, доступні транспортні механізми, як реалізувати стрімінг HTTP у MCP, найкращі практики безпеки, міграцію з SSE та практичні рекомендації для створення власних стрімінгових додатків MCP.

## Транспортні механізми та стрімінг у MCP

Цей розділ досліджує різні транспортні механізми, доступні в MCP, та їх роль у забезпеченні можливостей стрімінгу для реального часу комунікації між клієнтами та серверами.

### Що таке транспортний механізм?

Транспортний механізм визначає, як дані обмінюються між клієнтом і сервером. MCP підтримує кілька типів транспорту для задоволення різних середовищ і вимог:

- **stdio**: Стандартний ввід/вивід, підходить для локальних та CLI-інструментів. Простий, але не підходить для вебу чи хмари.
- **SSE (Server-Sent Events)**: Дозволяє серверам надсилати оновлення в реальному часі клієнтам через HTTP. Добре підходить для веб-інтерфейсів, але має обмеження у масштабованості та гнучкості.
- **Streamable HTTP**: Сучасний HTTP-стрімінговий транспорт, що підтримує сповіщення та кращу масштабованість. Рекомендується для більшості виробничих і хмарних сценаріїв.

### Таблиця порівняння

Ознайомтеся з таблицею порівняння нижче, щоб зрозуміти відмінності між цими транспортними механізмами:

| Транспорт          | Оновлення в реальному часі | Стрімінг | Масштабованість | Сценарій використання       |
|--------------------|---------------------------|----------|-----------------|-----------------------------|
| stdio              | Ні                        | Ні       | Низька          | Локальні CLI-інструменти    |
| SSE                | Так                       | Так      | Середня         | Веб, оновлення в реальному часі |
| Streamable HTTP    | Так                       | Так      | Висока          | Хмара, багатоклієнтські додатки |

> **Порада:** Вибір правильного транспорту впливає на продуктивність, масштабованість і досвід користувача. **Streamable HTTP** рекомендується для сучасних, масштабованих і готових до хмари додатків.

Зверніть увагу на транспорти stdio та SSE, які були розглянуті в попередніх розділах, і як Streamable HTTP є транспортом, що охоплюється в цьому розділі.

## Стрімінг: концепції та мотивація

Розуміння основних концепцій і мотивації стрімінгу є важливим для впровадження ефективних систем комунікації в реальному часі.

**Стрімінг** — це техніка в мережевому програмуванні, яка дозволяє надсилати та отримувати дані невеликими, керованими частинами або як послідовність подій, а не чекати, поки весь відповідь буде готовий. Це особливо корисно для:

- Великих файлів або наборів даних.
- Оновлень у реальному часі (наприклад, чат, індикатори прогресу).
- Тривалих обчислень, де потрібно інформувати користувача.

Ось що потрібно знати про стрімінг на високому рівні:

- Дані доставляються поступово, а не всі одразу.
- Клієнт може обробляти дані по мірі їх надходження.
- Зменшує сприйману затримку та покращує досвід користувача.

### Чому використовувати стрімінг?

Причини використання стрімінгу такі:

- Користувачі отримують зворотний зв'язок негайно, а не лише в кінці.
- Дозволяє створювати додатки в реальному часі та чутливі інтерфейси.
- Більш ефективне використання мережевих і обчислювальних ресурсів.

### Простий приклад: HTTP стрімінговий сервер і клієнт

Ось простий приклад того, як можна реалізувати стрімінг:

#### Python

**Сервер (Python, використовуючи FastAPI та StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**Клієнт (Python, використовуючи requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

Цей приклад демонструє сервер, який надсилає серію повідомлень клієнту по мірі їх готовності, а не чекає, поки всі повідомлення будуть готові.

**Як це працює:**

- Сервер передає кожне повідомлення по мірі його готовності.
- Клієнт отримує та друкує кожну частину по мірі її надходження.

**Вимоги:**

- Сервер повинен використовувати стрімінгову відповідь (наприклад, `StreamingResponse` у FastAPI).
- Клієнт повинен обробляти відповідь як стрімінг (`stream=True` у requests).
- Content-Type зазвичай `text/event-stream` або `application/octet-stream`.

#### Java

**Сервер (Java, використовуючи Spring Boot та Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Клієнт (Java, використовуючи Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Примітки до реалізації Java:**

- Використовує реактивний стек Spring Boot з `Flux` для стрімінгу.
- `ServerSentEvent` забезпечує структурований стрімінг подій з типами подій.
- `WebClient` з `bodyToFlux()` дозволяє реактивне споживання стрімінгу.
- `delayElements()` імітує час обробки між подіями.
- Події можуть мати типи (`info`, `result`) для кращої обробки клієнтом.

### Порівняння: класичний стрімінг vs стрімінг MCP

Відмінності між тим, як стрімінг працює "класичним" способом, і тим, як він працює в MCP, можна зобразити так:

| Особливість            | Класичний HTTP стрімінг       | MCP стрімінг (сповіщення)         |
|------------------------|-----------------------------|-----------------------------------|
| Основна відповідь      | Частинами                   | Єдина, в кінці                   |
| Оновлення прогресу     | Надсилаються як частини даних | Надсилаються як сповіщення       |
| Вимоги до клієнта      | Повинен обробляти стрімінг   | Повинен реалізувати обробник повідомлень |
| Сценарій використання  | Великі файли, AI токени      | Прогрес, логи, зворотний зв'язок в реальному часі |

### Спостережувані ключові відмінності

Додатково, ось деякі ключові відмінності:

- **Шаблон комунікації:**
  - Класичний HTTP стрімінг: Використовує просте кодування chunked transfer для надсилання даних частинами.
  - MCP стрімінг: Використовує структуровану систему сповіщень з протоколом JSON-RPC.

- **Формат повідомлень:**
  - Класичний HTTP: Простий текст частинами з новими рядками.
  - MCP: Структуровані об'єкти LoggingMessageNotification з метаданими.

- **Реалізація клієнта:**
  - Класичний HTTP: Простий клієнт, який обробляє стрімінгові відповіді.
  - MCP: Більш складний клієнт з обробником повідомлень для обробки різних типів повідомлень.

- **Оновлення прогресу:**
  - Класичний HTTP: Прогрес є частиною основного стрімінгу відповіді.
  - MCP: Прогрес надсилається через окремі повідомлення про сповіщення, тоді як основна відповідь надходить в кінці.

### Рекомендації

Ось кілька рекомендацій щодо вибору між реалізацією класичного стрімінгу (як кінцевої точки `/stream`, яку ми показали вище) та стрімінгу через MCP.

- **Для простих потреб стрімінгу:** Класичний HTTP стрімінг простіший у реалізації та достатній для базових потреб стрімінгу.

- **Для складних, інтерактивних додатків:** MCP стрімінг забезпечує більш структурований підхід з багатшими метаданими та розділенням між сповіщеннями та кінцевими результатами.

- **Для AI-додатків:** Система сповіщень MCP особливо корисна для тривалих AI-завдань, де потрібно інформувати користувачів про прогрес.

## Стрімінг у MCP

Отже, ви вже бачили деякі рекомендації та порівняння щодо відмінностей між класичним стрімінгом і стрімінгом у MCP. Давайте детально розглянемо, як саме можна використовувати стрімінг у MCP.

Розуміння того, як стрімінг працює в рамках MCP, є важливим для створення чутливих додатків, які забезпечують зворотний зв'язок у реальному часі для користувачів під час тривалих операцій.

У MCP стрімінг не стосується надсилання основної відповіді частинами, а стосується надсилання **сповіщень** клієнту під час обробки запиту інструментом. Ці сповіщення можуть включати оновлення прогресу, логи або інші події.

### Як це працює

Основний результат все ще надсилається як єдина відповідь. Однак сповіщення можуть надсилатися як окремі повідомлення під час обробки, тим самим оновлюючи клієнта в реальному часі. Клієнт повинен бути здатним обробляти та відображати ці сповіщення.

## Що таке сповіщення?

Ми згадали "сповіщення", що це означає в контексті MCP?

Сповіщення — це повідомлення, яке надсилається сервером клієнту для інформування про прогрес, статус або інші події під час тривалої операції. Сповіщення покращують прозорість і досвід користувача.

Наприклад, клієнт повинен надіслати сповіщення після початкового рукостискання з сервером.

Сповіщення виглядає як JSON-повідомлення:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

Сповіщення належать до теми в MCP, яка називається ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging).

Щоб увімкнути логування, сервер повинен активувати цю функцію/можливість, як показано нижче:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> Залежно від використовуваного SDK, логування може бути увімкнено за замовчуванням, або вам може знадобитися явно увімкнути його в конфігурації сервера.

Існують різні типи сповіщень:

| Рівень     | Опис                          | Приклад використання            |
|------------|-------------------------------|---------------------------------|
| debug      | Детальна інформація для відладки | Точки входу/виходу функції      |
| info       | Загальні інформаційні повідомлення | Оновлення прогресу операції     |
| notice     | Нормальні, але значущі події  | Зміни конфігурації              |
| warning    | Умови попередження            | Використання застарілих функцій |
| error      | Умови помилки                 | Збої операції                   |
| critical   | Критичні умови                | Збої компонентів системи        |
| alert      | Необхідно негайно діяти       | Виявлено пошкодження даних      |
| emergency  | Система не працює             | Повний збій системи             |

## Реалізація сповіщень у MCP

Щоб реалізувати сповіщення в MCP, потрібно налаштувати як серверну, так і клієнтську сторони для обробки оновлень у реальному часі. Це дозволяє вашому додатку надавати негайний зворотний зв'язок користувачам під час тривалих операцій.

### Серверна сторона: Надсилання сповіщень

Почнемо з серверної сторони. У MCP ви визначаєте інструменти, які можуть надсилати сповіщення під час обробки запитів. Сервер використовує об'єкт контексту (зазвичай `ctx`) для надсилання повідомлень клієнту.

#### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

У наведеному прикладі інструмент `process_files` надсилає три сповіщення клієнту під час обробки кожного файлу. Метод `ctx.info()` використовується для надсилання інформаційних повідомлень.

Додатково, щоб увімкнути сповіщення, переконайтеся, що ваш сервер використовує стрімінговий транспорт (наприклад, `streamable-http`), а ваш клієнт реалізує обробник повідомлень для обробки сповіщень. Ось як можна налаштувати сервер для використання транспорту `streamable-http`:

```python
mcp.run(transport="streamable-http")
```

#### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

У цьому прикладі .NET інструмент `ProcessFiles` позначений атрибутом `Tool` і надсилає три сповіщення клієнту під час обробки кожного файлу. Метод `ctx.Info()` використовується для надсилання інформаційних повідомлень.

Щоб увімкнути сповіщення у вашому сервері MCP на .NET, переконайтеся, що ви використовуєте стрімінговий транспорт:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### Клієнтська сторона: Отримання сповіщень

Клієнт повинен реалізувати обробник повідомлень для обробки та відображення сповіщень по мірі їх надходження.

#### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

У наведеному коді функція `message_handler` перевіряє, чи є вхідне повідомлення сповіщенням. Якщо так, вона друкує сповіщення; якщо ні, обробляє його як звичайне серверне повідомлення. Також зверніть увагу, як `ClientSession` ініціалізується з `message_handler` для обробки вхідних сповіщень.

#### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

У цьому прикладі .NET функція `MessageHandler` перевіряє, чи є вхідне повідомлення сповіщенням. Якщо так, вона друкує сповіщення; якщо ні, обробляє його як звичайне серверне повідомлення. `ClientSession` ініціалізується з обробником повідомлень через `ClientSessionOptions`.

Щоб увімкнути сповіщення, переконайтеся, що ваш сервер використовує стрімінговий транспорт (наприклад, `streamable-http`), а ваш клієнт реалізує обробник повідомлень для обробки сповіщень.

## Сповіщення про прогрес та сценарії

Цей розділ пояснює концепцію сповіщень про прогрес у MCP, чому вони важливі, і як їх реалізувати за допомогою Streamable HTTP. Ви також знайдете практичне завдання для закріплення вашого розуміння.

Сповіщення про прогрес — це реальні повідомлення, які надсилаються сервером клієнту під час тривалих операцій. Замість того, щоб чекати завершення всього процесу, сервер оновлює клієнта про поточний статус. Це покращує прозорість, досвід користувача та спрощує відладку.

**Приклад:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### Чому використовувати сповіщення про прогрес?

Сповіщення про прогрес важливі з кількох причин:

- **Кращий досвід користувача:** Користувачі бачать оновлення по мірі виконання роботи, а не лише в кінці.
- **Зворотний зв'язок у реальному часі:** Клієнти можуть відображати індикатори прогресу або логи, роблячи додаток більш чутливим.
- **Простіша відладка та моніторинг:** Розробники та користувачі можуть бачити, де процес може бути повільним або застряглим.

### Як реалізувати сповіщення про прогрес

Ось як можна реалізувати сповіщення про прогрес у MCP:

- **На сервері:** Використовуйте `ctx.info()` або `ctx.log()` для надсилання сповіщень по мірі об
Є дві вагомі причини для переходу з SSE на Streamable HTTP:

- Streamable HTTP забезпечує кращу масштабованість, сумісність і розширену підтримку сповіщень у порівнянні з SSE.
- Це рекомендований транспорт для нових MCP-додатків.

### Кроки міграції

Ось як можна перейти з SSE на Streamable HTTP у ваших MCP-додатках:

- **Оновіть серверний код**, використовуючи `transport="streamable-http"` у `mcp.run()`.
- **Оновіть клієнтський код**, замінивши SSE-клієнт на `streamablehttp_client`.
- **Реалізуйте обробник повідомлень** у клієнті для обробки сповіщень.
- **Перевірте сумісність** з існуючими інструментами та робочими процесами.

### Підтримка сумісності

Рекомендується підтримувати сумісність з існуючими SSE-клієнтами під час процесу міграції. Ось кілька стратегій:

- Ви можете підтримувати як SSE, так і Streamable HTTP, використовуючи різні кінцеві точки для кожного транспорту.
- Поступово переводьте клієнтів на новий транспорт.

### Виклики

Під час міграції важливо врахувати наступні виклики:

- Забезпечення оновлення всіх клієнтів
- Обробка відмінностей у доставці сповіщень

## Міркування щодо безпеки

Безпека повинна бути головним пріоритетом при реалізації будь-якого сервера, особливо при використанні HTTP-транспортів, таких як Streamable HTTP у MCP.

Реалізація MCP-серверів із використанням HTTP-транспортів вимагає ретельної уваги до різних векторів атак і механізмів захисту.

### Огляд

Безпека є критично важливою при відкритті MCP-серверів через HTTP. Streamable HTTP створює нові поверхні для атак і вимагає ретельної конфігурації.

Ось основні міркування щодо безпеки:

- **Перевірка заголовка Origin**: Завжди перевіряйте заголовок `Origin`, щоб запобігти атакам DNS rebinding.
- **Прив’язка до localhost**: Для локальної розробки прив’язуйте сервери до `localhost`, щоб уникнути їх відкриття для загального доступу.
- **Аутентифікація**: Реалізуйте аутентифікацію (наприклад, API-ключі, OAuth) для розгортання у виробничому середовищі.
- **CORS**: Налаштуйте політики Cross-Origin Resource Sharing (CORS) для обмеження доступу.
- **HTTPS**: Використовуйте HTTPS у виробничому середовищі для шифрування трафіку.

### Найкращі практики

Окрім цього, дотримуйтесь наступних найкращих практик при реалізації безпеки у вашому MCP-сервері потокової передачі:

- Ніколи не довіряйте вхідним запитам без перевірки.
- Логуйте та відстежуйте всі доступи та помилки.
- Регулярно оновлюйте залежності для усунення вразливостей безпеки.

### Виклики

Ви можете зіткнутися з такими викликами при реалізації безпеки у MCP-серверах потокової передачі:

- Балансування між безпекою та зручністю розробки
- Забезпечення сумісності з різними клієнтськими середовищами

### Завдання: Створіть власний потоковий MCP-додаток

**Сценарій:**
Створіть MCP-сервер і клієнт, де сервер обробляє список елементів (наприклад, файлів або документів) і надсилає сповіщення для кожного обробленого елемента. Клієнт повинен відображати кожне сповіщення в режимі реального часу.

**Кроки:**

1. Реалізуйте серверний інструмент, який обробляє список і надсилає сповіщення для кожного елемента.
2. Реалізуйте клієнт із обробником повідомлень для відображення сповіщень у режимі реального часу.
3. Перевірте вашу реалізацію, запустивши сервер і клієнт, і спостерігайте за сповіщеннями.

[Рішення](./solution/README.md)

## Додаткове читання та подальші кроки

Щоб продовжити вивчення MCP-потоків і розширити свої знання, цей розділ пропонує додаткові ресурси та наступні кроки для створення більш складних додатків.

### Додаткове читання

- [Microsoft: Вступ до HTTP Streaming](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS у ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Потокові запити](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Подальші кроки

- Спробуйте створити більш складні MCP-інструменти, які використовують потокову передачу для аналітики в реальному часі, чату або спільного редагування.
- Дослідіть інтеграцію MCP-потоків із фронтенд-фреймворками (React, Vue тощо) для оновлення інтерфейсу в реальному часі.
- Далі: [Використання AI Toolkit для VSCode](../07-aitk/README.md)

**Відмова від відповідальності**:  
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, майте на увазі, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.