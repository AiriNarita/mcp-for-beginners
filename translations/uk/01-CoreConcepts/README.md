<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0a6a7bcb289c024a91289e0444cb370b",
<<<<<<< HEAD
  "translation_date": "2025-08-18T22:47:04+00:00",
=======
  "translation_date": "2025-08-18T18:07:41+00:00",
>>>>>>> origin/main
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "uk"
}
-->
<<<<<<< HEAD
# Основні концепції MCP: Опанування Протоколу Контексту Моделі для інтеграції ШІ
=======
# Основні концепції MCP: Опанування протоколу контексту моделі для інтеграції AI
>>>>>>> origin/main

[![Основні концепції MCP](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.uk.png)](https://youtu.be/earDzWGtE84)

_(Натисніть на зображення вище, щоб переглянути відео цього уроку)_

<<<<<<< HEAD
[Model Context Protocol (MCP)](https://gi- **Явна згода користувача**: Усі операції та доступ до даних вимагають явного схвалення користувача перед виконанням. Користувачі повинні чітко розуміти, які дані будуть доступні та які дії будуть виконані, з можливістю детального контролю дозволів та авторизацій.

- **Захист конфіденційності даних**: Дані користувача розкриваються лише за явною згодою і повинні бути захищені надійними механізмами доступу протягом усього циклу взаємодії. Реалізації повинні запобігати несанкціонованій передачі даних і дотримуватися суворих меж конфіденційності.

- **Безпека виконання інструментів**: Кожен виклик інструменту вимагає явної згоди користувача з чітким розумінням функціональності інструменту, параметрів і потенційного впливу. Надійні межі безпеки повинні запобігати ненавмисному, небезпечному або зловмисному виконанню інструментів.

- **Безпека транспортного рівня**: Усі канали зв’язку повинні використовувати відповідні механізми шифрування та автентифікації. Віддалені з’єднання повинні реалізовувати безпечні транспортні протоколи та належне управління обліковими даними.

#### Рекомендації щодо реалізації:

- **Управління дозволами**: Реалізуйте системи з детальним управлінням дозволами, які дозволяють користувачам контролювати доступ до серверів, інструментів і ресурсів.
- **Автентифікація та авторизація**: Використовуйте безпечні методи автентифікації (OAuth, API-ключі) з належним управлінням токенами та їх терміном дії.  
- **Перевірка введених даних**: Перевіряйте всі параметри та введені дані відповідно до визначених схем, щоб запобігти атакам ін’єкцій.
- **Журнали аудиту**: Ведіть детальні журнали всіх операцій для моніторингу безпеки та відповідності.

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/specification/2025-06-18/) — це потужна стандартизована структура, яка оптимізує взаємодію між великими мовними моделями (LLMs) та зовнішніми інструментами, додатками й джерелами даних. Цей посібник допоможе вам зрозуміти основні концепції MCP, його архітектуру клієнт-сервер, ключові компоненти, механіку комунікації та найкращі практики реалізації.
=======
[Model Context Protocol (MCP)](https://gi- **Явна згода користувача**: Усі операції з доступом до даних вимагають явного схвалення користувача перед виконанням. Користувачі повинні чітко розуміти, які дані будуть доступні та які дії будуть виконані, з детальним контролем дозволів та авторизацій.

- **Захист конфіденційності даних**: Дані користувача розкриваються лише за явною згодою та повинні бути захищені надійними механізмами доступу протягом усього життєвого циклу взаємодії. Реалізації повинні запобігати несанкціонованій передачі даних і дотримуватися суворих меж конфіденційності.

- **Безпека виконання інструментів**: Кожен виклик інструменту вимагає явної згоди користувача з чітким розумінням функціональності інструменту, параметрів і потенційного впливу. Надійні межі безпеки повинні запобігати ненавмисному, небезпечному або зловмисному виконанню інструментів.

- **Безпека транспортного рівня**: Усі канали зв’язку повинні використовувати відповідні механізми шифрування та автентифікації. Віддалені з’єднання повинні впроваджувати захищені транспортні протоколи та належне управління обліковими даними.

#### Рекомендації щодо реалізації:

- **Управління дозволами**: Реалізуйте системи детального управління дозволами, які дозволяють користувачам контролювати, які сервери, інструменти та ресурси доступні
- **Автентифікація та авторизація**: Використовуйте безпечні методи автентифікації (OAuth, API-ключі) з належним управлінням токенами та їх терміном дії  
- **Валідація введення**: Перевіряйте всі параметри та введені дані відповідно до визначених схем, щоб запобігти атакам через ін’єкції
- **Журнали аудиту**: Ведіть комплексні журнали всіх операцій для моніторингу безпеки та відповідності вимогам
>>>>>>> origin/main

## Огляд

Цей урок досліджує фундаментальну архітектуру та компоненти, які складають екосистему Model Context Protocol (MCP). Ви дізнаєтеся про архітектуру клієнт-сервер, ключові компоненти та механізми комунікації, які забезпечують взаємодію MCP.

## Основні навчальні цілі

<<<<<<< HEAD
До кінця цього уроку ви зможете:

- Зрозуміти архітектуру клієнт-сервер MCP.
- Визначити ролі та обов’язки Хостів, Клієнтів і Серверів.
- Проаналізувати основні функції, які роблять MCP гнучким шаром інтеграції.
- Дізнатися, як інформація циркулює в екосистемі MCP.
- Отримати практичні знання через приклади коду на .NET, Java, Python і JavaScript.

## Архітектура MCP: Глибший погляд

Екосистема MCP побудована на моделі клієнт-сервер. Ця модульна структура дозволяє ШІ-додаткам ефективно взаємодіяти з інструментами, базами даних, API та контекстними ресурсами. Давайте розглянемо цю архітектуру детальніше.
=======
До кінця цього уроку ви:

- Зрозумієте архітектуру клієнт-сервер MCP.
- Визначите ролі та обов’язки Хостів, Клієнтів і Серверів.
- Проаналізуєте основні функції, які роблять MCP гнучким інтеграційним шаром.
- Дізнаєтеся, як інформація переміщується в екосистемі MCP.
- Отримаєте практичні знання через приклади коду в .NET, Java, Python і JavaScript.

## Архітектура MCP: детальний огляд

Екосистема MCP побудована на моделі клієнт-сервер. Ця модульна структура дозволяє AI-додаткам ефективно взаємодіяти з інструментами, базами даних, API та контекстними ресурсами. Давайте розглянемо цю архітектуру в її основних компонентах.
>>>>>>> origin/main

У своїй основі MCP дотримується архітектури клієнт-сервер, де хост-додаток може підключатися до кількох серверів:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

<<<<<<< HEAD
- **Хости MCP**: Програми, такі як VSCode, Claude Desktop, IDE або інструменти ШІ, які хочуть отримати доступ до даних через MCP.
- **Клієнти MCP**: Протокольні клієнти, які підтримують 1:1 з’єднання із серверами.
- **Сервери MCP**: Легкі програми, які надають певні можливості через стандартизований Model Context Protocol.
- **Локальні джерела даних**: Файли, бази даних і сервіси вашого комп’ютера, до яких сервери MCP можуть безпечно отримати доступ.
- **Віддалені сервіси**: Зовнішні системи, доступні через інтернет, до яких сервери MCP можуть підключатися через API.

Протокол MCP є еволюційним стандартом, який використовує версіонування за датою (формат YYYY-MM-DD). Поточна версія протоколу — **2025-06-18**. Ви можете переглянути останні оновлення [специфікації протоколу](https://modelcontextprotocol.io/specification/2025-06-18/).

### 1. Хости

У Model Context Protocol (MCP) **Хости** — це ШІ-додатки, які виступають основним інтерфейсом, через який користувачі взаємодіють із протоколом. Хости координують і керують з’єднаннями з кількома серверами MCP, створюючи виділених клієнтів MCP для кожного з’єднання. Приклади Хостів:

- **ШІ-додатки**: Claude Desktop, Visual Studio Code, Claude Code.
- **Середовища розробки**: IDE та редактори коду з інтеграцією MCP.  
- **Кастомні додатки**: Спеціально створені агенти ШІ та інструменти.

**Хости** — це додатки, які координують взаємодію з моделями ШІ. Вони:

- **Організовують роботу моделей ШІ**: Виконують або взаємодіють із LLM для генерації відповідей і координації робочих процесів ШІ.
- **Керують з’єднаннями клієнтів**: Створюють і підтримують одного клієнта MCP для кожного з’єднання з сервером MCP.
- **Контролюють інтерфейс користувача**: Обробляють потік розмов, взаємодію з користувачем і подання відповідей.  
- **Забезпечують безпеку**: Контролюють дозволи, обмеження безпеки та автентифікацію.
- **Керують згодою користувача**: Організовують схвалення користувачем обміну даними та виконання інструментів.

### 2. Клієнти

**Клієнти** — це ключові компоненти, які підтримують виділені з’єднання один-на-один між Хостами та серверами MCP. Кожен клієнт MCP створюється Хостом для підключення до конкретного сервера MCP, забезпечуючи організовані та безпечні канали зв’язку. Кілька клієнтів дозволяють Хостам одночасно підключатися до кількох серверів.

**Клієнти** — це з’єднувальні компоненти в межах хост-додатка. Вони:

- **Комунікація за протоколом**: Надсилають запити JSON-RPC 2.0 до серверів із підказками та інструкціями.
- **Узгодження можливостей**: Узгоджують підтримувані функції та версії протоколу із серверами під час ініціалізації.
- **Виконання інструментів**: Керують запитами на виконання інструментів від моделей і обробляють відповіді.
- **Оновлення в реальному часі**: Обробляють сповіщення та оновлення в реальному часі від серверів.
- **Обробка відповідей**: Обробляють і форматують відповіді серверів для відображення користувачам.
=======
- **Хости MCP**: Програми, такі як VSCode, Claude Desktop, IDE або AI-інструменти, які хочуть отримати доступ до даних через MCP
- **Клієнти MCP**: Протокольні клієнти, які підтримують 1:1 з’єднання із серверами
- **Сервери MCP**: Легкі програми, які кожен надає певні можливості через стандартизований Model Context Protocol
- **Локальні джерела даних**: Файли, бази даних і сервіси вашого комп’ютера, до яких сервери MCP можуть безпечно отримати доступ
- **Віддалені сервіси**: Зовнішні системи, доступні через Інтернет, до яких сервери MCP можуть підключатися через API.

Протокол MCP є еволюційним стандартом, який використовує версії на основі дати (формат YYYY-MM-DD). Поточна версія протоколу — **2025-06-18**. Ви можете переглянути останні оновлення [специфікації протоколу](https://modelcontextprotocol.io/specification/2025-06-18/)

### 1. Хости

У Model Context Protocol (MCP) **Хости** — це AI-додатки, які виступають основним інтерфейсом, через який користувачі взаємодіють із протоколом. Хости координують і керують з’єднаннями з кількома серверами MCP, створюючи спеціалізованих клієнтів MCP для кожного з’єднання сервера. Приклади Хостів включають:

- **AI-додатки**: Claude Desktop, Visual Studio Code, Claude Code
- **Середовища розробки**: IDE та редактори коду з інтеграцією MCP  
- **Користувацькі додатки**: Спеціалізовані AI-агенти та інструменти

**Хости** — це додатки, які координують взаємодію моделей AI. Вони:

- **Організовують AI-моделі**: Виконують або взаємодіють із LLM для генерації відповідей і координації AI-робочих процесів
- **Керують з’єднаннями клієнтів**: Створюють і підтримують одного клієнта MCP для кожного з’єднання сервера MCP
- **Контролюють інтерфейс користувача**: Обробляють потік розмов, взаємодію з користувачем і представлення відповідей  
- **Забезпечують безпеку**: Контролюють дозволи, обмеження безпеки та автентифікацію
- **Керують згодою користувача**: Організовують схвалення користувача для обміну даними та виконання інструментів

### 2. Клієнти

**Клієнти** — це важливі компоненти, які підтримують спеціалізовані одноосібні з’єднання між Хостами та серверами MCP. Кожен клієнт MCP створюється Хостом для підключення до конкретного сервера MCP, забезпечуючи організовані та безпечні канали зв’язку. Кілька клієнтів дозволяють Хостам одночасно підключатися до кількох серверів.

**Клієнти** — це компоненти-з’єднувачі в додатку Хоста. Вони:

- **Протокольна комунікація**: Надсилають запити JSON-RPC 2.0 до серверів із підказками та інструкціями
- **Переговори можливостей**: Узгоджують підтримувані функції та версії протоколу із серверами під час ініціалізації
- **Виконання інструментів**: Керують запитами на виконання інструментів від моделей і обробляють відповіді
- **Оновлення в реальному часі**: Обробляють сповіщення та оновлення в реальному часі від серверів
- **Обробка відповідей**: Обробляють і форматують відповіді серверів для відображення користувачам
>>>>>>> origin/main

### 3. Сервери

**Сервери** — це програми, які надають контекст, інструменти та можливості клієнтам MCP. Вони можуть виконуватися локально (на тому ж комп’ютері, що й Хост) або віддалено (на зовнішніх платформах) і відповідають за обробку запитів клієнтів і надання структурованих відповідей. Сервери надають певну функціональність через стандартизований Model Context Protocol.

**Сервери** — це сервіси, які надають контекст і можливості. Вони:

<<<<<<< HEAD
- **Реєстрація функцій**: Реєструють і надають доступні примітиви (ресурси, підказки, інструменти) клієнтам.
- **Обробка запитів**: Отримують і виконують виклики інструментів, запити ресурсів і підказок від клієнтів.
- **Надання контексту**: Надають контекстну інформацію та дані для покращення відповідей моделі.
- **Управління станом**: Підтримують стан сесії та обробляють станні взаємодії за потреби.
- **Сповіщення в реальному часі**: Надсилають сповіщення про зміни можливостей і оновлення підключеним клієнтам.

Сервери можуть бути розроблені будь-ким для розширення можливостей моделі за допомогою спеціалізованої функціональності та підтримують як локальні, так і віддалені сценарії розгортання.
=======
- **Реєстрація функцій**: Реєструють і надають доступні примітиви (ресурси, підказки, інструменти) клієнтам
- **Обробка запитів**: Отримують і виконують виклики інструментів, запити ресурсів і запити підказок від клієнтів
- **Надання контексту**: Надають контекстну інформацію та дані для покращення відповідей моделі
- **Управління станом**: Підтримують стан сеансу та обробляють взаємодії зі станом, коли це необхідно
- **Сповіщення в реальному часі**: Надсилають сповіщення про зміни можливостей і оновлення підключеним клієнтам

Сервери можуть бути розроблені будь-ким для розширення можливостей моделі за допомогою спеціалізованої функціональності, і вони підтримують як локальні, так і віддалені сценарії розгортання.
>>>>>>> origin/main

### 4. Примітиви серверів

Сервери в Model Context Protocol (MCP) надають три основні **примітиви**, які визначають фундаментальні будівельні блоки для багатих взаємодій між клієнтами, хостами та мовними моделями. Ці примітиви визначають типи контекстної інформації та дій, доступних через протокол.

<<<<<<< HEAD
Сервери MCP можуть надавати будь-яку комбінацію таких трьох основних примітивів:

#### Ресурси

**Ресурси** — це джерела даних, які надають контекстну інформацію для ШІ-додатків. Вони представляють статичний або динамічний контент, який може покращити розуміння моделі та прийняття рішень:

- **Контекстні дані**: Структурована інформація та контекст для споживання моделлю ШІ.
- **Бази знань**: Репозиторії документів, статті, посібники та наукові праці.
- **Локальні джерела даних**: Файли, бази даних і локальна системна інформація.  
- **Зовнішні дані**: Відповіді API, веб-сервіси та дані віддалених систем.
- **Динамічний контент**: Дані в реальному часі, які оновлюються залежно від зовнішніх умов.

Ресурси ідентифікуються за URI та підтримують виявлення через методи `resources/list` і отримання через `resources/read`:
=======
Сервери MCP можуть надавати будь-яку комбінацію з наступних трьох основних примітивів:

#### Ресурси

**Ресурси** — це джерела даних, які надають контекстну інформацію AI-додаткам. Вони представляють статичний або динамічний контент, який може покращити розуміння моделі та прийняття рішень:

- **Контекстні дані**: Структурована інформація та контекст для споживання AI-моделлю
- **Бази знань**: Репозиторії документів, статті, посібники та наукові роботи
- **Локальні джерела даних**: Файли, бази даних і локальна системна інформація  
- **Зовнішні дані**: Відповіді API, веб-сервіси та дані віддалених систем
- **Динамічний контент**: Дані в реальному часі, які оновлюються залежно від зовнішніх умов

Ресурси ідентифікуються за URI та підтримують пошук через методи `resources/list` і отримання через `resources/read`:
>>>>>>> origin/main

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### Підказки

**Підказки** — це багаторазові шаблони, які допомагають структурувати взаємодії з мовними моделями. Вони забезпечують стандартизовані шаблони взаємодії та робочі процеси:

<<<<<<< HEAD
- **Шаблонні взаємодії**: Попередньо структуровані повідомлення та початки розмов.
- **Шаблони робочих процесів**: Стандартизовані послідовності для типових завдань і взаємодій.
- **Приклади Few-shot**: Шаблони на основі прикладів для інструкцій моделі.
- **Системні підказки**: Основні підказки, які визначають поведінку моделі та контекст.
- **Динамічні шаблони**: Параметризовані підказки, які адаптуються до конкретних контекстів.

Підказки підтримують підстановку змінних і можуть бути виявлені через `prompts/list` і отримані за допомогою `prompts/get`:
=======
- **Шаблонні взаємодії**: Попередньо структуровані повідомлення та початки розмов
- **Шаблони робочих процесів**: Стандартизовані послідовності для загальних завдань і взаємодій
- **Приклади Few-shot**: Шаблони на основі прикладів для інструкцій моделі
- **Системні підказки**: Основні підказки, які визначають поведінку моделі та контекст
- **Динамічні шаблони**: Підказки з параметрами, які адаптуються до конкретних контекстів

Підказки підтримують заміну змінних і можуть бути знайдені через `prompts/list` та отримані за допомогою `prompts/get`:
>>>>>>> origin/main

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### Інструменти

**Інструменти** — це виконувані функції, які мовні моделі можуть викликати для виконання конкретних дій. Вони представляють "дієслова" екосистеми MCP, дозволяючи моделям взаємодіяти із зовнішніми системами:

<<<<<<< HEAD
- **Виконувані функції**: Окремі операції, які моделі можуть викликати з конкретними параметрами.
- **Інтеграція зовнішніх систем**: Виклики API, запити до баз даних, операції з файлами, обчислення.
- **Унікальна ідентичність**: Кожен інструмент має унікальну назву, опис і схему параметрів.
- **Структурований ввід/вивід**: Інструменти приймають перевірені параметри та повертають структуровані, типізовані відповіді.
- **Можливості дій**: Дозволяють моделям виконувати реальні дії та отримувати актуальні дані.

Інструменти визначаються за допомогою JSON Schema для перевірки параметрів, виявляються через `tools/list` і виконуються за допомогою `tools/call`:
=======
- **Виконувані функції**: Окремі операції, які моделі можуть викликати з конкретними параметрами
- **Інтеграція зовнішніх систем**: Виклики API, запити до баз даних, операції з файлами, обчислення
- **Унікальна ідентичність**: Кожен інструмент має унікальне ім’я, опис і схему параметрів
- **Структурований ввід/вивід**: Інструменти приймають перевірені параметри та повертають структуровані, типізовані відповіді
- **Можливості дій**: Дозволяють моделям виконувати реальні дії та отримувати актуальні дані

Інструменти визначаються за допомогою JSON Schema для перевірки параметрів і знаходяться через `tools/list`, а виконуються через `tools/call`:
>>>>>>> origin/main

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## Примітиви клієнтів

<<<<<<< HEAD
У Model Context Protocol (MCP) **клієнти** можуть надавати примітиви, які дозволяють серверам запитувати додаткові можливості від хост-додатка. Ці примітиви на стороні клієнта дозволяють створювати багатші, інтерактивніші реалізації серверів, які можуть отримувати доступ до можливостей моделі ШІ та взаємодії з користувачем.

### Семплінг

**Семплінг** дозволяє серверам запитувати завершення від мовної моделі через ШІ-додаток клієнта. Цей примітив дозволяє серверам отримувати доступ до можливостей LLM без необхідності інтеграції власних залежностей моделі:

- **Доступ без залежності від моделі**: Сервери можуть запитувати завершення без включення SDK LLM або управління доступом до моделі.
- **Ініційований сервером ШІ**: Дозволяє серверам автономно генерувати контент за допомогою моделі клієнта.
- **Рекурсивні взаємодії LLM**: Підтримує складні сценарії, де серверам потрібна допомога ШІ для обробки.
- **Генерація динамічного контенту**: Дозволяє серверам створювати контекстуальні відповіді за допомогою моделі хоста.

Семплінг ініціюється через метод `sampling/complete`, де сервери надсилають запити на завершення клієнтам.

### Еліцитація  

**Еліцитація** дозволяє серверам запитувати додаткову інформацію або підтвердження від користувачів через інтерфейс клієнта:

- **Запити введення користувача**: Сервери можуть запитувати додаткову інформацію, необхідну для виконання інструменту.
- **Діалоги підтвердження**: Запитують схвалення користувача для чутливих або значущих операцій.
- **Інтерактивні робочі процеси**: Дозволяють серверам створювати покрокові взаємодії з користувачем.
- **Динамічний збір параметрів**: Збирають відсутні або необов’язкові параметри під час виконання інструменту.

Запити еліцитації здійснюються за допомогою методу `elicitation/request` для збору введення користувача через інтерфейс клієнта.

### Логування

**Логування** дозволяє серверам надсилати структуровані журнали клієнтам для налагодження, моніторингу та операційної прозорості:

- **Підтримка налагодження**: Дозволяє серверам надавати детальні журнали виконання для усунення несправностей.
- **Операційний моніторинг**: Надсилає оновлення статусу та метрики продуктивності клі
- **Управління життєвим циклом**: Відповідає за ініціалізацію з'єднання, узгодження можливостей і завершення сесії між клієнтами та серверами  
- **Серверні примітиви**: Дозволяє серверам надавати основну функціональність через інструменти, ресурси та шаблони  
- **Клієнтські примітиви**: Дозволяє серверам запитувати вибірки від LLM, отримувати введення від користувача та надсилати журнальні повідомлення  
=======
У Model Context Protocol (MCP) **клієнти** можуть надавати примітиви, які дозволяють серверам запитувати додаткові можливості від додатку Хоста. Ці примітиви на стороні клієнта дозволяють створювати багатші, інтерактивніші серверні реалізації, які можуть отримувати доступ до можливостей AI-моделі та взаємодії з користувачем.

### Семплінг

**Семплінг** дозволяє серверам запитувати завершення мовної моделі від AI-додатку клієнта. Цей примітив дозволяє серверам отримувати доступ до можливостей LLM без вбудовування власних залежностей моделі:

- **Доступ без залежності від моделі**: Сервери можуть запитувати завершення без включення SDK LLM або управління доступом до моделі
- **AI, ініційований сервером**: Дозволяє серверам автономно генерувати контент за допомогою AI-моделі клієнта
- **Рекурсивні взаємодії LLM**: Підтримує складні сценарії, де серверам потрібна допомога AI для обробки
- **Динамічне створення контенту**: Дозволяє серверам створювати контекстуальні відповіді за допомогою моделі Хоста

Семплінг ініціюється через метод `sampling/complete`, де сервери надсилають запити на завершення клієнтам.

### Збір інформації  

**Збір інформації** дозволяє серверам запитувати додаткову інформацію або підтвердження від користувачів через інтерфейс клієнта:

- **Запити введення користувача**: Сервери можуть запитувати додаткову інформацію, коли це необхідно для виконання інструменту
- **Діалоги підтвердження**: Запитують схвалення користувача для чутливих або значущих операцій
- **Інтерактивні робочі процеси**: Дозволяють серверам створювати покрокові взаємодії з користувачем
- **Динамічний збір параметрів**: Збирають відсутні або необов’язкові параметри під час виконання інструменту

Запити на збір інформації здійснюються за допомогою методу `elicitation/request` для збору введення користувача через інтерфейс клієнта.

### Логування

**Логування** дозволяє серверам надсилати структуровані повідомлення журналу клієнтам для налагодження, моніторингу та оперативної видимості:

- **Підтримка налагодження**: Дозволяє серверам надавати детальні журнали виконання для усунення несправностей
- **Оперативний моніторинг**: Надсилає оновлення статусу та показники продуктивності клієнтам
- **Звітування про помилки**: Надає детальний контекст помилок і діагностичну інформацію
- **Аудиторські сліди**: Створює комплексні журнали операцій серверів і прийнятих рішень

Повідомлення журналу надсилаються клієнтам для забезпечення прозорості операцій серверів і полегшення налагодження.

## Потік інформації в MCP

Model Context Protocol (MCP) визначає структурований потік інформації між хостами, клієнтами,
- **Управління життєвим циклом**: Відповідає за ініціалізацію з'єднання, узгодження можливостей і завершення сеансу між клієнтами та серверами  
- **Серверні примітиви**: Дозволяє серверам надавати основну функціональність через інструменти, ресурси та шаблони  
- **Клієнтські примітиви**: Дозволяє серверам запитувати вибірку з LLM, отримувати введення від користувача та надсилати журнальні повідомлення  
>>>>>>> origin/main
- **Сповіщення в реальному часі**: Підтримує асинхронні сповіщення для динамічних оновлень без опитування  

#### Основні функції:

- **Узгодження версії протоколу**: Використовує версії на основі дати (YYYY-MM-DD) для забезпечення сумісності  
- **Виявлення можливостей**: Клієнти та сервери обмінюються інформацією про підтримувані функції під час ініціалізації  
<<<<<<< HEAD
- **Сесії зі збереженням стану**: Підтримує стан з'єднання через кілька взаємодій для забезпечення контексту  
=======
- **Сеанси зі збереженням стану**: Підтримує стан з'єднання протягом кількох взаємодій для забезпечення контексту  
>>>>>>> origin/main

### Транспортний рівень

**Транспортний рівень** керує каналами зв'язку, формуванням повідомлень і автентифікацією між учасниками MCP:

<<<<<<< HEAD
#### Підтримувані механізми транспорту:

1. **Транспорт STDIO**:
   - Використовує стандартні потоки вводу/виводу для прямого зв'язку між процесами  
   - Оптимальний для локальних процесів на одній машині без мережевого навантаження  
=======
#### Підтримувані транспортні механізми:

1. **Транспорт STDIO**:
   - Використовує стандартні потоки вводу/виводу для прямого зв'язку між процесами  
   - Оптимальний для локальних процесів на одній машині без мережевих витрат  
>>>>>>> origin/main
   - Зазвичай використовується для локальних реалізацій серверів MCP  

2. **Транспорт HTTP зі стрімінгом**:
   - Використовує HTTP POST для повідомлень від клієнта до сервера  
   - Опціональні події, що надсилаються сервером (SSE), для стрімінгу від сервера до клієнта  
   - Дозволяє віддалений зв'язок із сервером через мережі  
<<<<<<< HEAD
   - Підтримує стандартну автентифікацію HTTP (токени доступу, API-ключі, користувацькі заголовки)  
=======
   - Підтримує стандартну автентифікацію HTTP (токени доступу, ключі API, спеціальні заголовки)  
>>>>>>> origin/main
   - MCP рекомендує OAuth для безпечної автентифікації на основі токенів  

#### Абстракція транспорту:

<<<<<<< HEAD
Транспортний рівень абстрагує деталі зв'язку від рівня даних, дозволяючи використовувати однаковий формат повідомлень JSON-RPC 2.0 для всіх механізмів транспорту. Ця абстракція дозволяє додаткам безперешкодно перемикатися між локальними та віддаленими серверами.

### Міркування щодо безпеки

Реалізації MCP повинні дотримуватися кількох критичних принципів безпеки, щоб забезпечити безпечні, надійні та захищені взаємодії у всіх операціях протоколу:

- **Згода та контроль користувача**: Користувачі повинні надати явну згоду перед доступом до будь-яких даних або виконанням операцій. Вони повинні мати чіткий контроль над тим, які дані передаються і які дії дозволені, підтримуваний інтуїтивно зрозумілими інтерфейсами для перегляду та затвердження активностей.

- **Конфіденційність даних**: Дані користувача повинні бути доступні лише за явною згодою і захищені відповідними засобами контролю доступу. Реалізації MCP повинні запобігати несанкціонованій передачі даних і забезпечувати конфіденційність протягом усіх взаємодій.

- **Безпека інструментів**: Перед викликом будь-якого інструменту потрібна явна згода користувача. Користувачі повинні чітко розуміти функціональність кожного інструменту, а також повинні бути встановлені надійні межі безпеки, щоб запобігти ненавмисному або небезпечному виконанню інструментів.

Дотримуючись цих принципів безпеки, MCP забезпечує довіру користувачів, конфіденційність і безпеку у всіх взаємодіях протоколу, одночасно дозволяючи потужні інтеграції AI.
=======
Транспортний рівень абстрагує деталі зв'язку від рівня даних, дозволяючи використовувати однаковий формат повідомлень JSON-RPC 2.0 для всіх транспортних механізмів. Ця абстракція дозволяє додаткам легко перемикатися між локальними та віддаленими серверами.

### Міркування щодо безпеки

Реалізації MCP повинні дотримуватися кількох критичних принципів безпеки, щоб забезпечити безпечні, надійні та захищені взаємодії в усіх операціях протоколу:

- **Згода та контроль користувача**: Користувачі повинні надавати явну згоду перед доступом до будь-яких даних або виконанням операцій. Вони повинні мати чіткий контроль над тим, які дані передаються і які дії дозволені, підтримуваний інтуїтивно зрозумілими інтерфейсами для перегляду та затвердження активностей.

- **Конфіденційність даних**: Дані користувача повинні бути доступні лише за явною згодою і захищені відповідними засобами контролю доступу. Реалізації MCP повинні запобігати несанкціонованій передачі даних і забезпечувати конфіденційність протягом усіх взаємодій.

- **Безпека інструментів**: Перед викликом будь-якого інструменту потрібна явна згода користувача. Користувачі повинні чітко розуміти функціональність кожного інструменту, а також повинні бути встановлені надійні межі безпеки для запобігання ненавмисному або небезпечному виконанню інструментів.

Дотримуючись цих принципів безпеки, MCP забезпечує довіру користувачів, конфіденційність і безпеку, зберігаючи при цьому потужні інтеграції з AI.
>>>>>>> origin/main

## Приклади коду: ключові компоненти

Нижче наведено приклади коду на кількох популярних мовах програмування, які демонструють, як реалізувати ключові компоненти серверів MCP та інструментів.

### Приклад .NET: створення простого сервера MCP з інструментами

<<<<<<< HEAD
Ось практичний приклад коду на .NET, який демонструє, як реалізувати простий сервер MCP із користувацькими інструментами. Цей приклад показує, як визначати та реєструвати інструменти, обробляти запити та підключати сервер за допомогою протоколу Model Context Protocol.
=======
Ось практичний приклад коду на .NET, який демонструє, як реалізувати простий сервер MCP із власними інструментами. У цьому прикладі показано, як визначати та реєструвати інструменти, обробляти запити та підключати сервер за допомогою протоколу Model Context Protocol.
>>>>>>> origin/main

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Приклад Java: компоненти сервера MCP

Цей приклад демонструє той самий сервер MCP і реєстрацію інструментів, що й у прикладі .NET, але реалізований на Java.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Приклад Python: створення сервера MCP

У цьому прикладі показано, як створити сервер MCP на Python. Також показано два різні способи створення інструментів.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### Приклад JavaScript: створення сервера MCP

Цей приклад демонструє створення сервера MCP на JavaScript і реєстрацію двох інструментів, пов'язаних із погодою.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

<<<<<<< HEAD
Цей приклад JavaScript демонструє, як створити клієнт MCP, який підключається до сервера, надсилає запит і обробляє відповідь, включаючи будь-які виклики інструментів.
=======
Цей приклад JavaScript демонструє, як створити клієнт MCP, який підключається до сервера, надсилає запит і обробляє відповідь, включаючи виклики інструментів.
>>>>>>> origin/main

## Безпека та авторизація

MCP включає кілька вбудованих концепцій і механізмів для управління безпекою та авторизацією протягом усього протоколу:

1. **Контроль дозволів для інструментів**:  
<<<<<<< HEAD
   Клієнти можуть вказувати, які інструменти дозволено використовувати моделі під час сесії. Це гарантує, що доступні лише явно дозволені інструменти, знижуючи ризик ненавмисних або небезпечних операцій. Дозволи можуть налаштовуватися динамічно на основі уподобань користувача, політик організації або контексту взаємодії.

2. **Автентифікація**:  
   Сервери можуть вимагати автентифікацію перед наданням доступу до інструментів, ресурсів або чутливих операцій. Це може включати API-ключі, токени OAuth або інші схеми автентифікації. Належна автентифікація гарантує, що лише довірені клієнти та користувачі можуть викликати функції сервера.

3. **Валідація**:  
   Перевірка параметрів здійснюється для всіх викликів інструментів. Кожен інструмент визначає очікувані типи, формати та обмеження для своїх параметрів, а сервер перевіряє вхідні запити відповідно. Це запобігає надходженню некоректного або шкідливого вводу до реалізацій інструментів і допомагає зберігати цілісність операцій.

4. **Обмеження швидкості**:  
   Щоб запобігти зловживанням і забезпечити справедливе використання ресурсів сервера, сервери MCP можуть реалізовувати обмеження швидкості для викликів інструментів і доступу до ресурсів. Обмеження швидкості можуть застосовуватися для кожного користувача, кожної сесії або глобально, і допомагають захистити від атак типу "відмова в обслуговуванні" або надмірного споживання ресурсів.
=======
   Клієнти можуть вказувати, які інструменти дозволено використовувати моделі під час сеансу. Це гарантує, що доступні лише явно дозволені інструменти, знижуючи ризик ненавмисних або небезпечних операцій. Дозволи можуть налаштовуватися динамічно залежно від уподобань користувача, політик організації або контексту взаємодії.

2. **Автентифікація**:  
   Сервери можуть вимагати автентифікацію перед наданням доступу до інструментів, ресурсів або чутливих операцій. Це може включати ключі API, токени OAuth або інші схеми автентифікації. Належна автентифікація гарантує, що лише довірені клієнти та користувачі можуть викликати функції сервера.

3. **Валідація**:  
   Валідація параметрів забезпечується для всіх викликів інструментів. Кожен інструмент визначає очікувані типи, формати та обмеження для своїх параметрів, а сервер перевіряє вхідні запити відповідно. Це запобігає надходженню некоректного або шкідливого введення до реалізацій інструментів і допомагає зберігати цілісність операцій.

4. **Обмеження швидкості**:  
   Щоб запобігти зловживанням і забезпечити справедливе використання ресурсів сервера, сервери MCP можуть реалізовувати обмеження швидкості для викликів інструментів і доступу до ресурсів. Обмеження швидкості можуть застосовуватися для кожного користувача, сеансу або глобально, і допомагають захистити від атак типу "відмова в обслуговуванні" або надмірного споживання ресурсів.
>>>>>>> origin/main

Поєднуючи ці механізми, MCP забезпечує надійну основу для інтеграції мовних моделей із зовнішніми інструментами та джерелами даних, надаючи користувачам і розробникам детальний контроль над доступом і використанням.

## Повідомлення протоколу та потік комунікації

Комунікація MCP використовує структуровані повідомлення **JSON-RPC 2.0** для забезпечення чітких і надійних взаємодій між хостами, клієнтами та серверами. Протокол визначає конкретні шаблони повідомлень для різних типів операцій:

### Основні типи повідомлень:

#### **Повідомлення ініціалізації**
- **Запит `initialize`**: Встановлює з'єднання та узгоджує версію протоколу та можливості  
- **Відповідь `initialize`**: Підтверджує підтримувані функції та інформацію про сервер  
<<<<<<< HEAD
- **`notifications/initialized`**: Сигналізує, що ініціалізація завершена і сесія готова  
=======
- **`notifications/initialized`**: Сигналізує, що ініціалізація завершена і сеанс готовий  
>>>>>>> origin/main

#### **Повідомлення виявлення**
- **Запит `tools/list`**: Виявляє доступні інструменти на сервері  
- **Запит `resources/list`**: Перелічує доступні ресурси (джерела даних)  
- **Запит `prompts/list`**: Отримує доступні шаблони запитів  

#### **Повідомлення виконання**  
- **Запит `tools/call`**: Виконує конкретний інструмент із наданими параметрами  
- **Запит `resources/read`**: Отримує вміст із конкретного ресурсу  
- **Запит `prompts/get`**: Отримує шаблон запиту з опціональними параметрами  

<<<<<<< HEAD
#### **Повідомлення з боку клієнта**
=======
#### **Повідомлення на стороні клієнта**
>>>>>>> origin/main
- **Запит `sampling/complete`**: Сервер запитує завершення LLM від клієнта  
- **`elicitation/request`**: Сервер запитує введення користувача через інтерфейс клієнта  
- **Журнальні повідомлення**: Сервер надсилає структуровані журнальні повідомлення клієнту  

#### **Повідомлення сповіщень**
- **`notifications/tools/list_changed`**: Сервер повідомляє клієнта про зміни інструментів  
- **`notifications/resources/list_changed`**: Сервер повідомляє клієнта про зміни ресурсів  
- **`notifications/prompts/list_changed`**: Сервер повідомляє клієнта про зміни шаблонів  

### Структура повідомлень:

Усі повідомлення MCP відповідають формату JSON-RPC 2.0 із:  
- **Запитами**: Включають `id`, `method` і опціональні `params`  
- **Відповідями**: Включають `id` і або `result`, або `error`  
- **Сповіщеннями**: Включають `method` і опціональні `params` (без `id` або очікуваної відповіді)  

Ця структурована комунікація забезпечує надійні, відстежувані та розширювані взаємодії, підтримуючи складні сценарії, такі як оновлення в реальному часі, ланцюжки інструментів і надійне оброблення помилок.

## Основні висновки

- **Архітектура**: MCP використовує архітектуру клієнт-сервер, де хости керують кількома клієнтськими з'єднаннями із серверами  
- **Учасники**: Екосистема включає хости (AI-додатки), клієнти (конектори протоколу) і сервери (постачальники можливостей)  
<<<<<<< HEAD
- **Механізми транспорту**: Зв'язок підтримує STDIO (локальний) і HTTP зі стрімінгом із опціональним SSE (віддалений)  
- **Основні примітиви**: Сервери надають інструменти (виконувані функції), ресурси (джерела даних) і шаблони (запити)  
- **Клієнтські примітиви**: Сервери можуть запитувати вибірки (завершення LLM), введення (введення користувача) і журнальні повідомлення від клієнтів  
=======
- **Транспортні механізми**: Зв'язок підтримує STDIO (локальний) і HTTP зі стрімінгом із опціональним SSE (віддалений)  
- **Основні примітиви**: Сервери надають інструменти (виконувані функції), ресурси (джерела даних) і шаблони (запити)  
- **Клієнтські примітиви**: Сервери можуть запитувати вибірку (завершення LLM), отримання введення (користувацький ввід) і ведення журналу від клієнтів  
>>>>>>> origin/main
- **Основи протоколу**: Побудований на JSON-RPC 2.0 із версіями на основі дати (поточна: 2025-06-18)  
- **Можливості в реальному часі**: Підтримує сповіщення для динамічних оновлень і синхронізації в реальному часі  
- **Безпека перш за все**: Явна згода користувача, захист конфіденційності даних і безпечний транспорт є основними вимогами  

## Вправа

Розробіть простий інструмент MCP, який був би корисним у вашій галузі. Визначте:  
1. Як називатиметься інструмент  
2. Які параметри він прийматиме  
3. Який результат він повертатиме  
4. Як модель може використовувати цей інструмент для вирішення проблем користувача  

---

## Що далі

Далі: [Розділ 2: Безпека](../02-Security/README.md)

**Відмова від відповідальності**:  
<<<<<<< HEAD
Цей документ було перекладено за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, зверніть увагу, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ мовою оригіналу слід вважати авторитетним джерелом. Для критично важливої інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникли внаслідок використання цього перекладу.
=======
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, звертаємо вашу увагу, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критично важливої інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникли внаслідок використання цього перекладу.
>>>>>>> origin/main
