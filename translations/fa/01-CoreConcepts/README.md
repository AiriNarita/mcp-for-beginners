<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0a6a7bcb289c024a91289e0444cb370b",
  "translation_date": "2025-08-18T11:55:43+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "fa"
}
-->
# مفاهیم اصلی MCP: تسلط بر پروتکل مدل کانتکست برای یکپارچه‌سازی هوش مصنوعی

[![مفاهیم اصلی MCP](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.fa.png)](https://youtu.be/earDzWGtE84)

_(برای مشاهده ویدئوی این درس روی تصویر بالا کلیک کنید)_

[Model Context Protocol (MCP)](https://gi- **رضایت صریح کاربر**: دسترسی به داده‌ها و عملیات تنها با تأیید صریح کاربر انجام می‌شود. کاربران باید به‌طور واضح بدانند چه داده‌هایی دسترسی پیدا می‌کنند و چه اقداماتی انجام خواهد شد، با کنترل دقیق بر مجوزها و تأییدیه‌ها.

- **حفاظت از حریم خصوصی داده‌ها**: داده‌های کاربران تنها با رضایت صریح آنها در دسترس قرار می‌گیرد و باید در طول چرخه تعامل با کنترل‌های دسترسی قوی محافظت شود. پیاده‌سازی‌ها باید از انتقال غیرمجاز داده‌ها جلوگیری کرده و مرزهای حریم خصوصی را به‌طور دقیق حفظ کنند.

- **ایمنی اجرای ابزارها**: هر فراخوانی ابزار نیاز به رضایت صریح کاربر دارد، همراه با درک واضح از عملکرد ابزار، پارامترها و تأثیر احتمالی آن. مرزهای امنیتی قوی باید از اجرای ناخواسته، ناامن یا مخرب ابزارها جلوگیری کنند.

- **امنیت لایه انتقال**: تمام کانال‌های ارتباطی باید از مکانیزم‌های رمزنگاری و احراز هویت مناسب استفاده کنند. اتصالات راه دور باید پروتکل‌های انتقال امن و مدیریت صحیح اعتبارنامه‌ها را پیاده‌سازی کنند.

#### دستورالعمل‌های پیاده‌سازی:

- **مدیریت مجوزها**: سیستم‌های مجوز دقیق پیاده‌سازی کنید که به کاربران اجازه کنترل دسترسی به سرورها، ابزارها و منابع را بدهد  
- **احراز هویت و مجوزدهی**: از روش‌های احراز هویت امن (OAuth، کلیدهای API) با مدیریت صحیح توکن‌ها و انقضا استفاده کنید  
- **اعتبارسنجی ورودی**: تمام پارامترها و ورودی‌های داده را مطابق با طرح‌های تعریف‌شده اعتبارسنجی کنید تا از حملات تزریقی جلوگیری شود  
- **ثبت گزارشات**: گزارش‌های جامع از تمام عملیات برای نظارت امنیتی و رعایت قوانین نگهداری کنید  

## نمای کلی

این درس به بررسی معماری و اجزای اساسی که اکوسیستم پروتکل مدل کانتکست (MCP) را تشکیل می‌دهند، می‌پردازد. شما با معماری کلاینت-سرور، اجزای کلیدی و مکانیزم‌های ارتباطی که تعاملات MCP را قدرت می‌بخشند، آشنا خواهید شد.

## اهداف اصلی یادگیری

تا پایان این درس، شما:

- معماری کلاینت-سرور MCP را درک خواهید کرد.
- نقش‌ها و مسئولیت‌های میزبان‌ها، کلاینت‌ها و سرورها را شناسایی خواهید کرد.
- ویژگی‌های اصلی که MCP را به یک لایه یکپارچه‌سازی انعطاف‌پذیر تبدیل می‌کند، تحلیل خواهید کرد.
- نحوه جریان اطلاعات در اکوسیستم MCP را یاد خواهید گرفت.
- از طریق مثال‌های کدنویسی در .NET، Java، Python و JavaScript بینش عملی کسب خواهید کرد.

## معماری MCP: بررسی عمیق‌تر

اکوسیستم MCP بر اساس مدل کلاینت-سرور ساخته شده است. این ساختار ماژولار به برنامه‌های هوش مصنوعی اجازه می‌دهد تا به‌طور کارآمد با ابزارها، پایگاه‌های داده، APIها و منابع زمینه‌ای تعامل داشته باشند. بیایید این معماری را به اجزای اصلی آن تقسیم کنیم.

در هسته خود، MCP از معماری کلاینت-سرور پیروی می‌کند که در آن یک برنامه میزبان می‌تواند به چندین سرور متصل شود:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **میزبان‌های MCP**: برنامه‌هایی مانند VSCode، Claude Desktop، IDEها یا ابزارهای هوش مصنوعی که می‌خواهند از طریق MCP به داده‌ها دسترسی پیدا کنند  
- **کلاینت‌های MCP**: کلاینت‌های پروتکل که ارتباطات 1:1 با سرورها را حفظ می‌کنند  
- **سرورهای MCP**: برنامه‌های سبک که هر کدام قابلیت‌های خاصی را از طریق پروتکل استاندارد مدل کانتکست ارائه می‌دهند  
- **منابع داده محلی**: فایل‌ها، پایگاه‌های داده و خدمات کامپیوتر شما که سرورهای MCP می‌توانند به‌طور امن به آنها دسترسی پیدا کنند  
- **خدمات راه دور**: سیستم‌های خارجی که از طریق اینترنت در دسترس هستند و سرورهای MCP می‌توانند از طریق APIها به آنها متصل شوند  

پروتکل MCP یک استاندارد در حال تکامل است که از نسخه‌بندی مبتنی بر تاریخ (فرمت YYYY-MM-DD) استفاده می‌کند. نسخه فعلی پروتکل **2025-06-18** است. شما می‌توانید آخرین به‌روزرسانی‌های [مشخصات پروتکل](https://modelcontextprotocol.io/specification/2025-06-18/) را مشاهده کنید.

### 1. میزبان‌ها

در پروتکل مدل کانتکست (MCP)، **میزبان‌ها** برنامه‌های هوش مصنوعی هستند که به‌عنوان رابط اصلی عمل می‌کنند که کاربران از طریق آن با پروتکل تعامل دارند. میزبان‌ها با ایجاد کلاینت‌های MCP اختصاصی برای هر اتصال سرور، ارتباطات با چندین سرور MCP را هماهنگ و مدیریت می‌کنند. نمونه‌هایی از میزبان‌ها عبارتند از:

- **برنامه‌های هوش مصنوعی**: Claude Desktop، Visual Studio Code، Claude Code  
- **محیط‌های توسعه**: IDEها و ویرایشگرهای کد با یکپارچه‌سازی MCP  
- **برنامه‌های سفارشی**: عوامل و ابزارهای هوش مصنوعی طراحی‌شده برای اهداف خاص  

**میزبان‌ها** برنامه‌هایی هستند که تعاملات مدل هوش مصنوعی را هماهنگ می‌کنند. آنها:

- **مدل‌های هوش مصنوعی را هماهنگ می‌کنند**: اجرای یا تعامل با LLMها برای تولید پاسخ‌ها و هماهنگی جریان‌های کاری هوش مصنوعی  
- **اتصالات کلاینت را مدیریت می‌کنند**: یک کلاینت MCP برای هر اتصال سرور MCP ایجاد و حفظ می‌کنند  
- **رابط کاربری را کنترل می‌کنند**: جریان مکالمه، تعاملات کاربر و ارائه پاسخ‌ها را مدیریت می‌کنند  
- **امنیت را اجرا می‌کنند**: مجوزها، محدودیت‌های امنیتی و احراز هویت را کنترل می‌کنند  
- **رضایت کاربر را مدیریت می‌کنند**: تأیید کاربر برای اشتراک‌گذاری داده‌ها و اجرای ابزارها را مدیریت می‌کنند  

### 2. کلاینت‌ها

**کلاینت‌ها** اجزای ضروری هستند که ارتباطات اختصاصی یک‌به‌یک بین میزبان‌ها و سرورهای MCP را حفظ می‌کنند. هر کلاینت MCP توسط میزبان برای اتصال به یک سرور MCP خاص ایجاد می‌شود، که کانال‌های ارتباطی سازمان‌یافته و امن را تضمین می‌کند. کلاینت‌های متعدد به میزبان‌ها اجازه می‌دهند تا به‌طور همزمان به چندین سرور متصل شوند.

**کلاینت‌ها** اجزای اتصال‌دهنده درون برنامه میزبان هستند. آنها:

- **ارتباطات پروتکل**: درخواست‌های JSON-RPC 2.0 را با درخواست‌ها و دستورالعمل‌ها به سرورها ارسال می‌کنند  
- **مذاکره قابلیت‌ها**: ویژگی‌های پشتیبانی‌شده و نسخه‌های پروتکل را با سرورها در طول راه‌اندازی مذاکره می‌کنند  
- **اجرای ابزارها**: درخواست‌های اجرای ابزار از مدل‌ها را مدیریت کرده و پاسخ‌ها را پردازش می‌کنند  
- **به‌روزرسانی‌های بلادرنگ**: اعلان‌ها و به‌روزرسانی‌های بلادرنگ از سرورها را مدیریت می‌کنند  
- **پردازش پاسخ‌ها**: پاسخ‌های سرور را پردازش و برای نمایش به کاربران قالب‌بندی می‌کنند  

### 3. سرورها

**سرورها** برنامه‌هایی هستند که زمینه، ابزارها و قابلیت‌ها را به کلاینت‌های MCP ارائه می‌دهند. آنها می‌توانند به‌صورت محلی (روی همان دستگاه میزبان) یا راه دور (روی پلتفرم‌های خارجی) اجرا شوند و مسئولیت پردازش درخواست‌های کلاینت و ارائه پاسخ‌های ساختاریافته را بر عهده دارند. سرورها قابلیت‌های خاصی را از طریق پروتکل استاندارد مدل کانتکست ارائه می‌دهند.

**سرورها** خدماتی هستند که زمینه و قابلیت‌ها را ارائه می‌دهند. آنها:

- **ثبت ویژگی‌ها**: قابلیت‌های موجود (منابع، درخواست‌ها، ابزارها) را به کلاینت‌ها ثبت و ارائه می‌دهند  
- **پردازش درخواست‌ها**: درخواست‌های ابزار، منابع و درخواست‌های مدل را از کلاینت‌ها دریافت و اجرا می‌کنند  
- **ارائه زمینه**: اطلاعات زمینه‌ای و داده‌ها را برای بهبود پاسخ‌های مدل ارائه می‌دهند  
- **مدیریت وضعیت**: وضعیت جلسه را حفظ کرده و تعاملات حالت‌دار را در صورت نیاز مدیریت می‌کنند  
- **اعلان‌های بلادرنگ**: اعلان‌هایی درباره تغییرات قابلیت‌ها و به‌روزرسانی‌ها به کلاینت‌های متصل ارسال می‌کنند  

سرورها می‌توانند توسط هر کسی برای گسترش قابلیت‌های مدل با عملکردهای تخصصی توسعه داده شوند و از سناریوهای استقرار محلی و راه دور پشتیبانی می‌کنند.

### 4. عناصر اصلی سرور

سرورها در پروتکل مدل کانتکست (MCP) سه عنصر اصلی **عناصر اصلی** را ارائه می‌دهند که بلوک‌های سازنده اساسی برای تعاملات غنی بین کلاینت‌ها، میزبان‌ها و مدل‌های زبان را تعریف می‌کنند. این عناصر نوع اطلاعات زمینه‌ای و اقدامات موجود از طریق پروتکل را مشخص می‌کنند.

سرورهای MCP می‌توانند هر ترکیبی از سه عنصر اصلی زیر را ارائه دهند:

#### منابع

**منابع** منابع داده‌ای هستند که اطلاعات زمینه‌ای را به برنامه‌های هوش مصنوعی ارائه می‌دهند. آنها نمایانگر محتوای ثابت یا پویا هستند که می‌تواند درک و تصمیم‌گیری مدل را بهبود بخشد:

- **داده‌های زمینه‌ای**: اطلاعات ساختاریافته و زمینه برای مصرف مدل هوش مصنوعی  
- **پایگاه‌های دانش**: مخازن اسناد، مقالات، راهنماها و مقالات تحقیقاتی  
- **منابع داده محلی**: فایل‌ها، پایگاه‌های داده و اطلاعات سیستم محلی  
- **داده‌های خارجی**: پاسخ‌های API، خدمات وب و داده‌های سیستم‌های راه دور  
- **محتوای پویا**: داده‌های بلادرنگ که بر اساس شرایط خارجی به‌روزرسانی می‌شوند  

منابع با URIs شناسایی می‌شوند و از طریق روش‌های `resources/list` و `resources/read` قابل کشف و بازیابی هستند:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### درخواست‌ها

**درخواست‌ها** قالب‌های قابل استفاده مجدد هستند که به ساختار تعاملات با مدل‌های زبان کمک می‌کنند. آنها الگوهای تعامل استاندارد و جریان‌های کاری قالب‌بندی‌شده را ارائه می‌دهند:

- **تعاملات مبتنی بر قالب**: پیام‌های پیش‌ساختار و شروع‌کننده‌های مکالمه  
- **قالب‌های جریان کاری**: توالی‌های استاندارد برای وظایف و تعاملات رایج  
- **نمونه‌های چند‌شات**: قالب‌های مبتنی بر مثال برای دستورالعمل مدل  
- **درخواست‌های سیستمی**: درخواست‌های پایه‌ای که رفتار و زمینه مدل را تعریف می‌کنند  
- **قالب‌های پویا**: درخواست‌های پارامتری که به زمینه‌های خاص تطبیق می‌یابند  

درخواست‌ها از جایگزینی متغیر پشتیبانی می‌کنند و می‌توانند از طریق `prompts/list` کشف و با `prompts/get` بازیابی شوند:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### ابزارها

**ابزارها** توابع اجرایی هستند که مدل‌های هوش مصنوعی می‌توانند برای انجام اقدامات خاص فراخوانی کنند. آنها نمایانگر "افعال" اکوسیستم MCP هستند و به مدل‌ها اجازه می‌دهند با سیستم‌های خارجی تعامل داشته باشند:

- **توابع اجرایی**: عملیات‌های مجزا که مدل‌ها می‌توانند با پارامترهای خاص فراخوانی کنند  
- **یکپارچه‌سازی سیستم‌های خارجی**: فراخوانی‌های API، پرس‌وجوهای پایگاه داده، عملیات فایل، محاسبات  
- **هویت منحصربه‌فرد**: هر ابزار دارای نام، توضیحات و طرح پارامتر متمایز است  
- **ورودی/خروجی ساختاریافته**: ابزارها پارامترهای معتبر را می‌پذیرند و پاسخ‌های ساختاریافته و تایپ‌شده بازمی‌گردانند  
- **قابلیت‌های عملیاتی**: به مدل‌ها اجازه می‌دهند اقدامات واقعی انجام دهند و داده‌های زنده را بازیابی کنند  

ابزارها با JSON Schema برای اعتبارسنجی پارامترها تعریف می‌شوند و از طریق `tools/list` کشف و با `tools/call` اجرا می‌شوند:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## عناصر اصلی کلاینت

در پروتکل مدل کانتکست (MCP)، **کلاینت‌ها** می‌توانند عناصر اصلی را ارائه دهند که به سرورها اجازه می‌دهد قابلیت‌های اضافی را از برنامه میزبان درخواست کنند. این عناصر اصلی سمت کلاینت امکان پیاده‌سازی‌های سرور غنی‌تر و تعاملی‌تر را فراهم می‌کنند که می‌توانند به قابلیت‌های مدل هوش مصنوعی و تعاملات کاربر دسترسی داشته باشند.

### نمونه‌گیری

**نمونه‌گیری** به سرورها اجازه می‌دهد تا تکمیل‌های مدل زبان را از برنامه هوش مصنوعی کلاینت درخواست کنند. این عنصر اصلی به سرورها اجازه می‌دهد تا بدون وابستگی به مدل‌های خود، به قابلیت‌های LLM دسترسی پیدا کنند:

- **دسترسی مستقل از مدل**: سرورها می‌توانند تکمیل‌ها را بدون شامل کردن SDKهای LLM یا مدیریت دسترسی به مدل درخواست کنند  
- **هوش مصنوعی آغاز‌شده توسط سرور**: به سرورها اجازه می‌دهد به‌طور خودمختار محتوا را با استفاده از مدل هوش مصنوعی کلاینت تولید کنند  
- **تعاملات بازگشتی LLM**: از سناریوهای پیچیده‌ای که سرورها برای پردازش به کمک هوش مصنوعی نیاز دارند، پشتیبانی می‌کند  
- **تولید محتوای پویا**: به سرورها اجازه می‌دهد پاسخ‌های زمینه‌ای را با استفاده از مدل میزبان ایجاد کنند  

نمونه‌گیری از طریق روش `sampling/complete` آغاز می‌شود، که در آن سرورها درخواست‌های تکمیل را به کلاینت‌ها ارسال می‌کنند.

### استخراج اطلاعات

**استخراج اطلاعات** به سرورها اجازه می‌دهد تا اطلاعات اضافی یا تأییدیه از کاربران را از طریق رابط کلاینت درخواست کنند:

- **درخواست‌های ورودی کاربر**: سرورها می‌توانند اطلاعات اضافی را هنگام نیاز برای اجرای ابزار درخواست کنند  
- **دیالوگ‌های تأییدیه**: درخواست تأیید کاربر برای عملیات حساس یا تأثیرگذار  
- **جریان‌های کاری تعاملی**: به سرورها اجازه می‌دهد تعاملات مرحله‌به‌مرحله با کاربران ایجاد کنند  
- **جمع‌آوری پارامترهای پویا**: جمع‌آوری پارامترهای گم‌شده یا اختیاری در طول اجرای ابزار  

درخواست‌های استخراج اطلاعات با استفاده از روش `elicitation/request` برای جمع‌آوری ورودی کاربر از طریق رابط کلاینت انجام می‌شود.

### ثبت گزارشات

**ثبت گزارشات** به سرورها اجازه می‌دهد پیام‌های گزارش ساختاریافته را برای اشکال‌زدایی، نظارت و دید عملیاتی به کلاینت‌ها ارسال کنند:

- **پشتیبانی اشکال‌زدایی**: به سرورها اجازه می‌دهد گزارش‌های اجرایی دقیق برای رفع اشکال ارائه دهند  
- **نظارت عملیاتی**: ارسال به‌روزرسانی‌های وضعیت و معیارهای عملکرد به کلاینت‌ها  
- **گزارش خطا**: ارائه زمینه خطاهای دقیق و اطلاعات تشخیصی  
- **ردیابی حسابرسی**: ایجاد گزارش‌های جامع از عملیات و تصمیمات سرور  

پیام‌های ثبت گزارشات به کلاینت‌ها ارسال می‌شوند تا شفافیت در عملیات سرور را فراهم کنند و اشکال‌زدایی را تسهیل کنند.

## جریان اطلاعات در MCP

پروتکل مدل کانتکست (MCP) جریان ساختاریافته‌ای از اطلاعات بین میزبان‌ها، کلاینت‌ها، سرورها و مدل‌ها تعریف می‌کند. درک این جریان کمک می‌کند تا مشخص شود چگونه درخواست‌های کاربران پردازش می‌شوند و چگونه ابزارها و داده‌های خارجی در پاسخ‌های مدل یکپارچه می‌شوند.

- **میزبان اتصال را آغاز می‌کند**  
  برنامه میزبان (مانند یک IDE یا رابط چت) اتصال به یک سرور MCP را برقرار می‌کند، معمولاً از طریق STDIO، WebSocket یا یک روش انتقال پشتیبانی‌شده دیگر.

- **مذاکره قابلیت‌ها**  
  کلاینت (جاسازی‌شده در میزبان) و سرور اطلاعاتی درباره ویژگی‌های پشتیبانی‌شده، ابزارها، منابع و نسخه‌های پروتکل خود تبادل می‌کنند. این اطمینان می‌دهد که هر دو طرف قابلیت‌های موجود برای جلسه را درک می‌کنند.

- **درخواست کاربر**  
  کاربر با میزبان تعامل می‌کند (مثلاً یک درخواست یا فرمان وارد می‌کند). میزبان این ورودی را جمع‌آوری کرده و برای پردازش به کلاینت ارسال می‌کند.

- **استفاده از منابع یا ابزارها**  
  - کلاینت ممکن است زمینه یا منابع اضافی از سرور درخواست کند (مانند فایل‌ها، ورودی‌های پایگاه داده یا مقالات پایگاه دانش) تا درک مدل را غنی کند.  
  - اگر مدل تعیین کند که یک ابزار مورد نیاز است (مثلاً برای بازیابی داده‌ها، انجام محاسبه یا فراخوانی یک API)، کلاینت درخواست فراخوانی ابزار را به سرور ارسال می‌کند، با مشخص کردن نام ابزار و پارامترها.

- **اجرای سرور**  
  سرور درخواست منابع یا ابزار را دریافت کرده، عملیات‌های لازم را اجرا می‌کند (مانند اجرای یک تابع، پرس‌وجوی پایگاه داده یا بازیابی
- **مدیریت چرخه عمر**: مدیریت راه‌اندازی اتصال، مذاکره قابلیت‌ها و خاتمه جلسه بین کلاینت‌ها و سرورها  
- **ابتدائیات سرور**: امکان ارائه قابلیت‌های اصلی توسط سرورها از طریق ابزارها، منابع و قالب‌ها  
- **ابتدائیات کلاینت**: امکان درخواست نمونه‌گیری از مدل‌های زبانی بزرگ (LLM)، دریافت ورودی کاربر و ارسال پیام‌های لاگ توسط سرورها  
- **اعلان‌های بلادرنگ**: پشتیبانی از اعلان‌های غیرهمزمان برای به‌روزرسانی‌های پویا بدون نیاز به پرس‌وجو  

#### ویژگی‌های کلیدی:

- **مذاکره نسخه پروتکل**: استفاده از نسخه‌بندی مبتنی بر تاریخ (YYYY-MM-DD) برای اطمینان از سازگاری  
- **کشف قابلیت‌ها**: تبادل اطلاعات ویژگی‌های پشتیبانی‌شده بین کلاینت‌ها و سرورها در زمان راه‌اندازی  
- **جلسات با حالت پایدار**: حفظ وضعیت اتصال در تعاملات متعدد برای تداوم زمینه  

### لایه انتقال

**لایه انتقال** مدیریت کانال‌های ارتباطی، قالب‌بندی پیام‌ها و احراز هویت بین شرکت‌کنندگان MCP را بر عهده دارد:

#### مکانیزم‌های انتقال پشتیبانی‌شده:

1. **انتقال STDIO**:
   - استفاده از جریان‌های ورودی/خروجی استاندارد برای ارتباط مستقیم بین فرآیندها  
   - بهینه برای فرآیندهای محلی روی یک ماشین با سربار شبکه صفر  
   - معمولاً برای پیاده‌سازی‌های سرور MCP محلی استفاده می‌شود  

2. **انتقال HTTP قابل استریم**:
   - استفاده از HTTP POST برای پیام‌های کلاینت به سرور  
   - امکان استفاده از Server-Sent Events (SSE) برای استریم پیام‌های سرور به کلاینت  
   - امکان ارتباط با سرورهای راه دور از طریق شبکه‌ها  
   - پشتیبانی از احراز هویت استاندارد HTTP (توکن‌های حامل، کلیدهای API، هدرهای سفارشی)  
   - MCP استفاده از OAuth را برای احراز هویت امن مبتنی بر توکن توصیه می‌کند  

#### انتزاع انتقال:

لایه انتقال جزئیات ارتباط را از لایه داده انتزاع می‌کند و امکان استفاده از همان فرمت پیام JSON-RPC 2.0 را در تمام مکانیزم‌های انتقال فراهم می‌آورد. این انتزاع به برنامه‌ها اجازه می‌دهد به‌راحتی بین سرورهای محلی و راه دور جابه‌جا شوند.

### ملاحظات امنیتی

پیاده‌سازی‌های MCP باید از چندین اصل امنیتی حیاتی پیروی کنند تا تعاملات ایمن، قابل‌اعتماد و مطمئن در تمام عملیات پروتکل تضمین شود:

- **رضایت و کنترل کاربر**: کاربران باید قبل از دسترسی به هر داده یا انجام عملیات، رضایت صریح خود را اعلام کنند. آن‌ها باید کنترل واضحی بر داده‌های به‌اشتراک‌گذاشته‌شده و عملیات مجاز داشته باشند، که این امر با رابط‌های کاربری شهودی برای بررسی و تأیید فعالیت‌ها پشتیبانی می‌شود.  

- **حریم خصوصی داده‌ها**: داده‌های کاربران فقط با رضایت صریح آن‌ها در دسترس قرار می‌گیرد و باید با کنترل‌های دسترسی مناسب محافظت شود. پیاده‌سازی‌های MCP باید از انتقال غیرمجاز داده‌ها جلوگیری کرده و اطمینان حاصل کنند که حریم خصوصی در تمام تعاملات حفظ می‌شود.  

- **ایمنی ابزارها**: قبل از فراخوانی هر ابزار، رضایت صریح کاربر الزامی است. کاربران باید درک روشنی از عملکرد هر ابزار داشته باشند و مرزهای امنیتی قوی باید اعمال شود تا از اجرای ناخواسته یا ناامن ابزارها جلوگیری شود.  

با پیروی از این اصول امنیتی، MCP اطمینان حاصل می‌کند که اعتماد، حریم خصوصی و ایمنی کاربران در تمام تعاملات پروتکل حفظ می‌شود و در عین حال یکپارچگی قدرتمند با هوش مصنوعی را امکان‌پذیر می‌سازد.

## مثال‌های کد: اجزای کلیدی

در ادامه مثال‌هایی از کد در چند زبان برنامه‌نویسی محبوب آورده شده است که نحوه پیاده‌سازی اجزای کلیدی سرور MCP و ابزارها را نشان می‌دهد.

### مثال .NET: ایجاد یک سرور ساده MCP با ابزارها

در اینجا یک مثال عملی از کد .NET آورده شده است که نحوه پیاده‌سازی یک سرور ساده MCP با ابزارهای سفارشی را نشان می‌دهد. این مثال نحوه تعریف و ثبت ابزارها، مدیریت درخواست‌ها و اتصال سرور با استفاده از پروتکل Model Context را نمایش می‌دهد.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### مثال جاوا: اجزای سرور MCP

این مثال همان سرور MCP و ثبت ابزارها را که در مثال .NET بالا آورده شده است، اما با استفاده از جاوا پیاده‌سازی می‌کند.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### مثال پایتون: ساخت یک سرور MCP

در این مثال نشان داده می‌شود که چگونه یک سرور MCP در پایتون ساخته شود. همچنین دو روش مختلف برای ایجاد ابزارها نمایش داده شده است.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### مثال جاوااسکریپت: ایجاد یک سرور MCP

این مثال نحوه ایجاد یک سرور MCP در جاوااسکریپت و ثبت دو ابزار مرتبط با آب‌وهوا را نشان می‌دهد.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

این مثال جاوااسکریپت همچنین نحوه ایجاد یک کلاینت MCP که به سرور متصل می‌شود، ارسال یک درخواست، و پردازش پاسخ شامل هرگونه فراخوانی ابزار را نمایش می‌دهد.

## امنیت و مجوزدهی

MCP شامل چندین مفهوم و مکانیزم داخلی برای مدیریت امنیت و مجوزدهی در سراسر پروتکل است:

1. **کنترل مجوز ابزار**:  
   کلاینت‌ها می‌توانند مشخص کنند که کدام ابزارها در طول یک جلسه توسط مدل مجاز به استفاده هستند. این امر تضمین می‌کند که فقط ابزارهای صریحاً مجاز در دسترس هستند و خطر عملیات ناخواسته یا ناامن کاهش می‌یابد. مجوزها می‌توانند به‌صورت پویا بر اساس ترجیحات کاربر، سیاست‌های سازمانی یا زمینه تعامل پیکربندی شوند.  

2. **احراز هویت**:  
   سرورها می‌توانند قبل از اعطای دسترسی به ابزارها، منابع یا عملیات حساس، احراز هویت را الزامی کنند. این ممکن است شامل کلیدهای API، توکن‌های OAuth یا سایر طرح‌های احراز هویت باشد. احراز هویت مناسب تضمین می‌کند که فقط کلاینت‌ها و کاربران مورداعتماد می‌توانند قابلیت‌های سمت سرور را فراخوانی کنند.  

3. **اعتبارسنجی**:  
   اعتبارسنجی پارامترها برای تمام فراخوانی‌های ابزار اعمال می‌شود. هر ابزار انواع، قالب‌ها و محدودیت‌های موردانتظار برای پارامترهای خود را تعریف می‌کند و سرور درخواست‌های ورودی را به‌طور مناسب اعتبارسنجی می‌کند. این امر از رسیدن ورودی‌های نادرست یا مخرب به پیاده‌سازی ابزارها جلوگیری کرده و به حفظ یکپارچگی عملیات کمک می‌کند.  

4. **محدودیت نرخ**:  
   برای جلوگیری از سوءاستفاده و اطمینان از استفاده منصفانه از منابع سرور، سرورهای MCP می‌توانند محدودیت نرخ را برای فراخوانی ابزارها و دسترسی به منابع اعمال کنند. محدودیت‌های نرخ می‌توانند به‌صورت کاربرمحور، جلسه‌محور یا جهانی اعمال شوند و به محافظت در برابر حملات انکار سرویس یا مصرف بیش از حد منابع کمک کنند.  

با ترکیب این مکانیزم‌ها، MCP یک پایه امن برای یکپارچه‌سازی مدل‌های زبانی با ابزارها و منابع داده خارجی فراهم می‌کند، در حالی که کنترل دقیق بر دسترسی و استفاده را به کاربران و توسعه‌دهندگان می‌دهد.

## پیام‌های پروتکل و جریان ارتباطات

ارتباطات MCP از پیام‌های ساختاریافته **JSON-RPC 2.0** برای تسهیل تعاملات شفاف و قابل‌اعتماد بین میزبان‌ها، کلاینت‌ها و سرورها استفاده می‌کند. پروتکل الگوهای پیام خاصی را برای انواع مختلف عملیات تعریف می‌کند:

### انواع اصلی پیام‌ها:

#### **پیام‌های راه‌اندازی**
- **درخواست `initialize`**: اتصال را برقرار کرده و نسخه پروتکل و قابلیت‌ها را مذاکره می‌کند  
- **پاسخ `initialize`**: ویژگی‌های پشتیبانی‌شده و اطلاعات سرور را تأیید می‌کند  
- **`notifications/initialized`**: نشان می‌دهد که راه‌اندازی کامل شده و جلسه آماده است  

#### **پیام‌های کشف**
- **درخواست `tools/list`**: ابزارهای موجود در سرور را کشف می‌کند  
- **درخواست `resources/list`**: منابع موجود (منابع داده) را فهرست می‌کند  
- **درخواست `prompts/list`**: قالب‌های درخواست موجود را بازیابی می‌کند  

#### **پیام‌های اجرا**  
- **درخواست `tools/call`**: یک ابزار خاص را با پارامترهای ارائه‌شده اجرا می‌کند  
- **درخواست `resources/read`**: محتوای یک منبع خاص را بازیابی می‌کند  
- **درخواست `prompts/get`**: یک قالب درخواست را با پارامترهای اختیاری دریافت می‌کند  

#### **پیام‌های سمت کلاینت**
- **درخواست `sampling/complete`**: سرور درخواست تکمیل مدل زبانی از کلاینت می‌کند  
- **`elicitation/request`**: سرور از طریق رابط کلاینت درخواست ورودی کاربر می‌کند  
- **پیام‌های لاگ**: سرور پیام‌های لاگ ساختاریافته به کلاینت ارسال می‌کند  

#### **پیام‌های اعلان**
- **`notifications/tools/list_changed`**: سرور تغییرات ابزارها را به کلاینت اطلاع می‌دهد  
- **`notifications/resources/list_changed`**: سرور تغییرات منابع را به کلاینت اطلاع می‌دهد  
- **`notifications/prompts/list_changed`**: سرور تغییرات قالب‌ها را به کلاینت اطلاع می‌دهد  

### ساختار پیام:

تمام پیام‌های MCP از فرمت JSON-RPC 2.0 پیروی می‌کنند که شامل موارد زیر است:
- **پیام‌های درخواست**: شامل `id`، `method` و `params` اختیاری  
- **پیام‌های پاسخ**: شامل `id` و یا `result` یا `error`  
- **پیام‌های اعلان**: شامل `method` و `params` اختیاری (بدون `id` یا پاسخ مورد انتظار)  

این ارتباط ساختاریافته تعاملات قابل‌اعتماد، قابل‌ردیابی و قابل‌گسترش را پشتیبانی می‌کند که سناریوهای پیشرفته‌ای مانند به‌روزرسانی‌های بلادرنگ، زنجیره‌سازی ابزارها و مدیریت خطای قوی را امکان‌پذیر می‌سازد.

## نکات کلیدی

- **معماری**: MCP از معماری کلاینت-سرور استفاده می‌کند که در آن میزبان‌ها چندین اتصال کلاینت به سرورها را مدیریت می‌کنند  
- **شرکت‌کنندگان**: اکوسیستم شامل میزبان‌ها (برنامه‌های هوش مصنوعی)، کلاینت‌ها (اتصال‌دهنده‌های پروتکل) و سرورها (ارائه‌دهندگان قابلیت‌ها) است  
- **مکانیزم‌های انتقال**: ارتباطات از STDIO (محلی) و HTTP قابل استریم با SSE اختیاری (راه دور) پشتیبانی می‌کند  
- **ابتدائیات اصلی**: سرورها ابزارها (توابع اجرایی)، منابع (منابع داده) و قالب‌ها (الگوها) را ارائه می‌دهند  
- **ابتدائیات کلاینت**: سرورها می‌توانند نمونه‌گیری (تکمیل مدل زبانی)، دریافت ورودی (ورودی کاربر) و لاگ‌گیری را از کلاینت‌ها درخواست کنند  
- **پایه پروتکل**: مبتنی بر JSON-RPC 2.0 با نسخه‌بندی مبتنی بر تاریخ (نسخه فعلی: 2025-06-18)  
- **قابلیت‌های بلادرنگ**: از اعلان‌ها برای به‌روزرسانی‌های پویا و همگام‌سازی بلادرنگ پشتیبانی می‌کند  
- **امنیت در اولویت**: رضایت صریح کاربر، حفاظت از حریم خصوصی داده‌ها و انتقال امن الزامات اصلی هستند  

## تمرین

یک ابزار ساده MCP طراحی کنید که در حوزه کاری شما مفید باشد. مشخص کنید:
1. نام ابزار چه خواهد بود  
2. چه پارامترهایی را می‌پذیرد  
3. چه خروجی‌ای بازمی‌گرداند  
4. چگونه یک مدل ممکن است از این ابزار برای حل مشکلات کاربران استفاده کند  

---

## گام بعدی

بعدی: [فصل ۲: امنیت](../02-Security/README.md)  

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما برای دقت تلاش می‌کنیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است شامل خطاها یا نادرستی‌هایی باشند. سند اصلی به زبان اصلی آن باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حساس، ترجمه انسانی حرفه‌ای توصیه می‌شود. ما هیچ مسئولیتی در قبال سوءتفاهم‌ها یا تفسیرهای نادرست ناشی از استفاده از این ترجمه نداریم.