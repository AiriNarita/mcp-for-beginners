<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40b1bbffdb8ce6812bf6e701cad876b6",
  "translation_date": "2025-07-17T19:25:14+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "bg"
}
-->
# HTTPS стрийминг с Model Context Protocol (MCP)

Тази глава предоставя изчерпателно ръководство за реализиране на сигурен, мащабируем и в реално време стрийминг с Model Context Protocol (MCP) чрез HTTPS. Обхваща мотивацията за стрийминг, наличните транспортни механизми, как да се имплементира стрийминг HTTP в MCP, най-добри практики за сигурност, миграция от SSE и практически насоки за изграждане на собствени стрийминг MCP приложения.

## Транспортни механизми и стрийминг в MCP

Този раздел разглежда различните транспортни механизми, налични в MCP, и тяхната роля за осигуряване на стрийминг възможности за комуникация в реално време между клиенти и сървъри.

### Какво е транспортен механизъм?

Транспортният механизъм определя как се обменят данни между клиента и сървъра. MCP поддържа няколко типа транспорт, за да отговори на различни среди и изисквания:

- **stdio**: Стандартен вход/изход, подходящ за локални и CLI базирани инструменти. Прост, но не е подходящ за уеб или облак.
- **SSE (Server-Sent Events)**: Позволява на сървърите да изпращат актуализации в реално време към клиентите през HTTP. Подходящ за уеб интерфейси, но с ограничена мащабируемост и гъвкавост.
- **Streamable HTTP**: Модерен HTTP-базиран стрийминг транспорт, поддържащ нотификации и по-добра мащабируемост. Препоръчва се за повечето производствени и облачни сценарии.

### Таблица за сравнение

Вижте таблицата по-долу, за да разберете разликите между тези транспортни механизми:

| Транспорт         | Актуализации в реално време | Стрийминг | Мащабируемост | Приложение               |
|-------------------|-----------------------------|-----------|---------------|--------------------------|
| stdio             | Не                          | Не        | Ниска         | Локални CLI инструменти  |
| SSE               | Да                          | Да        | Средна        | Уеб, актуализации в реално време |
| Streamable HTTP   | Да                          | Да        | Висока        | Облак, мулти-клиент      |

> **Tip:** Изборът на правилния транспорт влияе на производителността, мащабируемостта и потребителското изживяване. **Streamable HTTP** е препоръчителен за модерни, мащабируеми и облачно готови приложения.

Обърнете внимание на транспортите stdio и SSE, които бяха разгледани в предишните глави, и как Streamable HTTP е транспортът, разгледан в тази глава.

## Стрийминг: Концепции и мотивация

Разбирането на основните концепции и мотивацията зад стрийминга е от съществено значение за внедряване на ефективни системи за комуникация в реално време.

**Стриймингът** е техника в мрежовото програмиране, която позволява данните да се изпращат и получават на малки, управляеми части или като поредица от събития, вместо да се чака цял отговор да бъде готов. Това е особено полезно за:

- Големи файлове или набори от данни.
- Актуализации в реално време (например чат, индикатори за напредък).
- Дълготрайни изчисления, при които искате да информирате потребителя.

Ето какво трябва да знаете за стрийминга на високо ниво:

- Данните се доставят постепенно, не наведнъж.
- Клиентът може да обработва данните веднага щом пристигнат.
- Намалява възприеманото забавяне и подобрява потребителското изживяване.

### Защо да използвате стрийминг?

Причините за използване на стрийминг са следните:

- Потребителите получават обратна връзка незабавно, а не само в края.
- Позволява приложения в реално време и отзивчиви интерфейси.
- По-ефективно използване на мрежовите и изчислителните ресурси.

### Прост пример: HTTP стрийминг сървър и клиент

Ето един прост пример как може да се реализира стрийминг:

#### Python

**Сървър (Python, използвайки FastAPI и StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**Клиент (Python, използвайки requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

Този пример демонстрира сървър, който изпраща серия от съобщения към клиента, докато те стават налични, вместо да чака всички съобщения да бъдат готови.

**Как работи:**

- Сървърът предоставя всяко съобщение, когато е готово.
- Клиентът получава и отпечатва всяка част, докато пристига.

**Изисквания:**
- Сървърът трябва да използва стрийминг отговор (например `StreamingResponse` във FastAPI).
- Клиентът трябва да обработва отговора като поток (`stream=True` в requests).
- Content-Type обикновено е `text/event-stream` или `application/octet-stream`.

#### Java

**Сървър (Java, използвайки Spring Boot и Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Клиент (Java, използвайки Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Бележки за Java имплементация:**

- Използва реактивния стек на Spring Boot с `Flux` за стрийминг.
- `ServerSentEvent` предоставя структурирано стрийминг на събития с типове събития.
- `WebClient` с `bodyToFlux()` позволява реактивно потребление на стрийминг.
- `delayElements()` симулира време за обработка между събитията.
- Събитията могат да имат типове (`info`, `result`) за по-добра обработка от клиента.

### Сравнение: Класически стрийминг срещу MCP стрийминг

Разликите между класическия начин на стрийминг и този в MCP могат да се илюстрират така:

| Функция                | Класически HTTP стрийминг      | MCP стрийминг (нотификации)       |
|------------------------|-------------------------------|----------------------------------|
| Основен отговор        | На части (chunked)             | Един, в края                     |
| Актуализации за напредък | Изпращат се като части от данни | Изпращат се като нотификации     |
| Изисквания към клиента | Трябва да обработва потока     | Трябва да имплементира обработчик на съобщения |
| Приложение             | Големи файлове, AI токен потоци | Напредък, логове, обратна връзка в реално време |

### Наблюдавани ключови разлики

Допълнително, ето някои ключови разлики:

- **Комуникационен модел:**
   - Класически HTTP стрийминг: Използва прост chunked transfer encoding за изпращане на данни на части
   - MCP стрийминг: Използва структурирана система за нотификации с JSON-RPC протокол

- **Формат на съобщенията:**
   - Класически HTTP: Обикновен текст с нови редове
   - MCP: Структурирани обекти LoggingMessageNotification с метаданни

- **Имплементация на клиента:**
  - Класически HTTP: Прост клиент, който обработва стрийминг отговори.
  - MCP: По-сложен клиент с обработчик на съобщения за обработка на различни типове съобщения.

- **Актуализации за напредък:**
   - Класически HTTP: Напредъкът е част от основния поток отговор
   - MCP: Напредъкът се изпраща чрез отделни нотификационни съобщения, докато основният отговор идва накрая

### Препоръки

Има някои препоръки при избора между класически стрийминг (като endpoint-а, показан по-горе с `/stream`) и стрийминг чрез MCP.

- **За прости нужди от стрийминг:** Класическият HTTP стрийминг е по-лесен за имплементиране и достатъчен за базови нужди.
- **За сложни, интерактивни приложения:** MCP стрийминг предлага по-структуриран подход с по-богати метаданни и разделение между нотификации и крайни резултати.
- **За AI приложения:** Системата за нотификации на MCP е особено полезна за дълготрайни AI задачи, където искате да държите потребителите информирани за напредъка.

## Стрийминг в MCP

Добре, вече видяхте някои препоръки и сравнения за разликите между класическия стрийминг и стрийминга в MCP. Нека разгледаме подробно как точно можете да използвате стрийминг в MCP.

Разбирането как работи стриймингът в рамките на MCP е ключово за изграждане на отзивчиви приложения, които предоставят обратна връзка в реално време на потребителите по време на дълготрайни операции.

В MCP стриймингът не означава изпращане на основния отговор на части, а изпращане на **нотификации** към клиента, докато инструментът обработва заявка. Тези нотификации могат да включват актуализации за напредък, логове или други събития.

### Как работи

Основният резултат все още се изпраща като един отговор. Въпреки това, нотификациите могат да се изпращат като отделни съобщения по време на обработката и така да актуализират клиента в реално време. Клиентът трябва да може да обработва и показва тези нотификации.

## Какво е нотификация?

Казахме "нотификация", какво означава това в контекста на MCP?

Нотификацията е съобщение, изпратено от сървъра към клиента, за да информира за напредък, статус или други събития по време на дълготрайна операция. Нотификациите подобряват прозрачността и потребителското изживяване.

Например, клиентът трябва да изпрати нотификация веднага след като първоначалното свързване със сървъра е осъществено.

Нотификацията изглежда така като JSON съобщение:

```json
{
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

Нотификациите принадлежат към тема в MCP, наречена ["Logging"](https://modelcontextprotocol.io/specification/draft/server/utilities/logging).

За да работи логването, сървърът трябва да го активира като функция/възможност, както следва:

```json
{
  "capabilities": {
    "logging": {}
  }
}
```

> [!NOTE]
> В зависимост от използвания SDK, логването може да е активирано по подразбиране или може да се наложи да го включите изрично в конфигурацията на сървъра.

Има различни типове нотификации:

| Ниво      | Описание                      | Примерна употреба             |
|-----------|-------------------------------|------------------------------|
| debug     | Подробна отстраняваща грешки информация | Вход/изход на функции        |
| info      | Общи информационни съобщения  | Актуализации за напредък     |
| notice    | Нормални, но значими събития  | Промени в конфигурацията     |
| warning   | Предупредителни състояния     | Използване на остаряла функция |
| error     | Грешки                       | Провали в операции           |
| critical  | Критични състояния            | Провали на системни компоненти |
| alert     | Необходимо е незабавно действие | Открита корупция на данни    |
| emergency | Системата е неизползваема     | Пълен системен срив          |

## Имплементиране на нотификации в MCP

За да имплементирате нотификации в MCP, трябва да настроите както сървърната, така и клиентската страна да обработват актуализации в реално време. Това позволява на вашето приложение да предоставя незабавна обратна връзка на потребителите по време на дълготрайни операции.

### От страна на сървъра: Изпращане на нотификации

Нека започнем със сървърната страна. В MCP дефинирате инструменти, които могат да изпращат нотификации по време на обработка на заявки. Сървърът използва контекстния обект (обикновено `ctx`), за да изпраща съобщения към клиента.

### Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    await ctx.info("Processing file 1/3...")
    await ctx.info("Processing file 2/3...")
    await ctx.info("Processing file 3/3...")
    return TextContent(type="text", text=f"Done: {message}")
```

В горния пример инструментът `process_files` изпраща три нотификации към клиента, докато обработва всеки файл. Методът `ctx.info()` се използва за изпращане на информационни съобщения.

Освен това, за да активирате нотификациите, уверете се, че сървърът използва стрийминг транспорт (като `streamable-http`), а клиентът имплементира обработчик на съобщения за обработка на нотификациите. Ето как да настроите сървъра да използва транспорта `streamable-http`:

```python
mcp.run(transport="streamable-http")
```

### .NET

```csharp
[Tool("A tool that sends progress notifications")]
public async Task<TextContent> ProcessFiles(string message, ToolContext ctx)
{
    await ctx.Info("Processing file 1/3...");
    await ctx.Info("Processing file 2/3...");
    await ctx.Info("Processing file 3/3...");
    return new TextContent
    {
        Type = "text",
        Text = $"Done: {message}"
    };
}
```

В този .NET пример инструментът `ProcessFiles` е декориран с атрибута `Tool` и изпраща три нотификации към клиента, докато обработва всеки файл. Методът `ctx.Info()` се използва за изпращане на информационни съобщения.

За да активирате нотификациите във вашия .NET MCP сървър, уверете се, че използвате стрийминг транспорт:

```csharp
var builder = McpBuilder.Create();
await builder
    .UseStreamableHttp() // Enable streamable HTTP transport
    .Build()
    .RunAsync();
```

### От страна на клиента: Получаване на нотификации

Клиентът трябва да имплементира обработчик на съобщения, който да обработва и показва нотификациите веднага щом пристигнат.

### Python

```python
async def message_handler(message):
    if isinstance(message, types.ServerNotification):
        print("NOTIFICATION:", message)
    else:
        print("SERVER MESSAGE:", message)

async with ClientSession(
   read_stream, 
   write_stream,
   logging_callback=logging_collector,
   message_handler=message_handler,
) as session:
```

В горния код функцията `message_handler` проверява дали входящото съобщение е нотификация. Ако е, го отпечатва; в противен случай го обработва като обикновено съобщение от сървъра. Обърнете внимание и как `ClientSession` се инициализира с `message_handler`, за да обработва входящите нотификации.

### .NET

```csharp
// Define a message handler
void MessageHandler(IJsonRpcMessage message)
{
    if (message is ServerNotification notification)
    {
        Console.WriteLine($"NOTIFICATION: {notification}");
    }
    else
    {
        Console.WriteLine($"SERVER MESSAGE: {message}");
    }
}

// Create and use a client session with the message handler
var clientOptions = new ClientSessionOptions
{
    MessageHandler = MessageHandler,
    LoggingCallback = (level, message) => Console.WriteLine($"[{level}] {message}")
};

using var client = new ClientSession(readStream, writeStream, clientOptions);
await client.InitializeAsync();

// Now the client will process notifications through the MessageHandler
```

В този .NET пример функцията `MessageHandler` проверява дали входящото съобщение е нотификация. Ако е, го отпечатва; в противен случай го обработва като обикновено съобщение от сървъра. `ClientSession` се инициализира с обработчика на съобщения чрез `ClientSessionOptions`.

За да активирате нотификациите, уверете се, че сървърът използва стрийминг транспорт (като `streamable-http`), а клиентът имплементира обработчик на съобщения за обработка на нотификациите.

## Нотификации за напредък и сценарии

Този раздел обяснява концепцията за нотификации за напредък в MCP, защо са важни и как да ги имплементирате с помощта на Streamable HTTP. Ще намерите и практическо задание за затвърждаване на знанията.

Нотификациите за напредък са съобщения в реално време, изпращани от сървъра към клиента по време на дълготрайни операции. Вместо да се чака цялата операция да приключи, сървърът държи клиента информиран за текущото състояние. Това подобрява прозрачността, потребителското изживяване и улеснява отстраняването на грешки.

**Пример:**

```text

"Processing document 1/10"
"Processing document 2/10"
...
"Processing complete!"

```

### Защо да използваме нотификации за напредък?

Нотификациите за напредък са важни по няколко причини:

- **По-добро потребителско изживяване:** Потребителите виждат актуализации в процеса на работа, а не само накрая.
- **Обратна връзка в реално време:** Клиентите могат да показват ленти за напредък или логове, което прави приложението по-отзивчиво.
- **По-лесно отстраняване на грешки и мониторинг:** Разработчиците и потребителите могат да видят къде процесът може да е бавен или блокиран.

### Как да имплементираме нотификации за напредък

Ето как можете да имплементирате нотификации за напредък в MCP:

- **На сървъра:** Използвайте `ctx.info()` или `ctx.log()`, за да изпращате нотификации при обработка на всеки елемент. Това изпраща съобщение към клиента преди основния резултат да е готов.
- **На клиента:** Имплементирайте обработчик на съобщения, който слуша и показва нотификациите веднага щом пристигнат. Този обработчик различава нотификациите от крайния резултат.

**Пример на сървър:**

## Python

```python
@mcp.tool(description="A tool that sends progress notifications")
async def process_files(message: str, ctx: Context) -> TextContent:
    for i in range(1, 11):
        await ctx.info(f"Processing document {i}/10")
    await ctx.info("Processing complete!")
    return TextContent(type="text", text=f"Done: {message}")
```


**Пример на клиент:
### Защо да надграждаме?

Има две основателни причини да преминете от SSE към Streamable HTTP:

- Streamable HTTP предлага по-добра мащабируемост, съвместимост и по-богата поддръжка за известия в сравнение със SSE.
- Това е препоръчителният транспорт за нови MCP приложения.

### Стъпки за миграция

Ето как можете да мигрирате от SSE към Streamable HTTP във вашите MCP приложения:

- **Актуализирайте сървърния код**, за да използва `transport="streamable-http"` в `mcp.run()`.
- **Актуализирайте клиентския код**, за да използва `streamablehttp_client` вместо SSE клиента.
- **Имплементирайте обработчик на съобщения** в клиента за обработка на известията.
- **Тествайте съвместимостта** с наличните инструменти и работни процеси.

### Поддържане на съвместимост

Препоръчително е да поддържате съвместимост с настоящите SSE клиенти по време на миграцията. Ето някои стратегии:

- Можете да поддържате и SSE, и Streamable HTTP, като пуснете двата транспорта на различни крайни точки.
- Постепенно мигрирайте клиентите към новия транспорт.

### Предизвикателства

Уверете се, че се справяте със следните предизвикателства по време на миграцията:

- Осигуряване, че всички клиенти са актуализирани
- Обработка на разликите в доставката на известия

## Съображения за сигурност

Сигурността трябва да бъде основен приоритет при внедряването на сървър, особено когато се използват HTTP-базирани транспорти като Streamable HTTP в MCP.

При имплементиране на MCP сървъри с HTTP-базирани транспорти, сигурността става ключов въпрос, който изисква внимателно внимание към множество вектори на атака и защитни механизми.

### Общ преглед

Сигурността е критична при експониране на MCP сървъри през HTTP. Streamable HTTP въвежда нови повърхности за атаки и изисква внимателна конфигурация.

Ето някои ключови съображения за сигурност:

- **Валидация на Origin заглавката**: Винаги валидирайте `Origin` заглавката, за да предотвратите DNS rebinding атаки.
- **Свързване към localhost**: За локална разработка свързвайте сървърите към `localhost`, за да избегнете излагане към публичния интернет.
- **Аутентикация**: Имплементирайте аутентикация (например API ключове, OAuth) за продукционни среди.
- **CORS**: Конфигурирайте политики за Cross-Origin Resource Sharing (CORS), за да ограничите достъпа.
- **HTTPS**: Използвайте HTTPS в продукция за криптиране на трафика.

### Най-добри практики

Освен това, ето някои най-добри практики при имплементиране на сигурност в MCP стрийминг сървър:

- Никога не се доверявайте на входящи заявки без валидиране.
- Логвайте и наблюдавайте всички достъпи и грешки.
- Редовно обновявайте зависимостите, за да поправяте уязвимости.

### Предизвикателства

Ще се сблъскате с някои предизвикателства при внедряване на сигурност в MCP стрийминг сървъри:

- Балансиране между сигурността и леснотата на разработка
- Осигуряване на съвместимост с различни клиентски среди

### Задача: Създайте собствено стрийминг MCP приложение

**Сценарий:**
Създайте MCP сървър и клиент, където сървърът обработва списък с елементи (например файлове или документи) и изпраща известие за всеки обработен елемент. Клиентът трябва да показва всяко известие в реално време.

**Стъпки:**

1. Имплементирайте сървърен инструмент, който обработва списък и изпраща известия за всеки елемент.
2. Имплементирайте клиент с обработчик на съобщения, който показва известията в реално време.
3. Тествайте имплементацията, като стартирате и сървъра, и клиента, и наблюдавате известията.

[Решение](./solution/README.md)

## Допълнително четене и какво следва?

За да продължите пътя си с MCP стрийминг и да разширите знанията си, този раздел предоставя допълнителни ресурси и препоръчани следващи стъпки за изграждане на по-сложни приложения.

### Допълнителна литература

- [Microsoft: Въведение в HTTP стрийминг](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS в ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Стрийминг заявки](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Какво следва?

- Опитайте да изградите по-сложни MCP инструменти, които използват стрийминг за анализи в реално време, чат или съвместно редактиране.
- Изследвайте интеграцията на MCP стрийминг с фронтенд рамки (React, Vue и др.) за живи UI ъпдейти.
- Следващо: [Използване на AI Toolkit за VSCode](../07-aitk/README.md)

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI преводаческа услуга [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи могат да съдържат грешки или неточности. Оригиналният документ на неговия първичен език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален човешки превод. Ние не носим отговорност за каквито и да е недоразумения или неправилни тълкувания, произтичащи от използването на този превод.