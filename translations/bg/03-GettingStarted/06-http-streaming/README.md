<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "5f1383103523fa822e1fec7ef81904d5",
  "translation_date": "2025-08-18T21:19:36+00:00",
  "source_file": "03-GettingStarted/06-http-streaming/README.md",
  "language_code": "bg"
}
-->
# HTTPS Стрийминг с Протокол за Контекст на Модела (MCP)

Тази глава предоставя изчерпателно ръководство за внедряване на сигурен, мащабируем и в реално време стрийминг с Протокол за Контекст на Модела (MCP), използвайки HTTPS. Тя обхваща мотивацията за стрийминг, наличните транспортни механизми, как да се внедри стрийминг HTTP в MCP, най-добрите практики за сигурност, миграция от SSE и практически насоки за изграждане на собствени MCP приложения за стрийминг.

## Транспортни механизми и стрийминг в MCP

Тази секция разглежда различните транспортни механизми, налични в MCP, и тяхната роля в осигуряването на възможности за стрийминг за комуникация в реално време между клиенти и сървъри.

### Какво е транспортен механизъм?

Транспортният механизъм определя как данните се обменят между клиента и сървъра. MCP поддържа няколко типа транспорт, за да отговори на различни среди и изисквания:

- **stdio**: Стандартен вход/изход, подходящ за локални и CLI-базирани инструменти. Прост, но неподходящ за уеб или облачни среди.
- **SSE (Server-Sent Events)**: Позволява на сървърите да изпращат актуализации в реално време към клиентите чрез HTTP. Добър за уеб интерфейси, но ограничен по отношение на мащабируемост и гъвкавост.
- **Streamable HTTP**: Модерен HTTP-базиран транспорт за стрийминг, поддържащ известия и по-добра мащабируемост. Препоръчва се за повечето производствени и облачни сценарии.

### Сравнителна таблица

Разгледайте таблицата по-долу, за да разберете разликите между тези транспортни механизми:

| Транспорт         | Актуализации в реално време | Стрийминг | Мащабируемост | Приложение                |
|-------------------|-----------------------------|-----------|---------------|---------------------------|
| stdio             | Не                          | Не        | Ниска         | Локални CLI инструменти   |
| SSE               | Да                          | Да        | Средна        | Уеб, актуализации в реално време |
| Streamable HTTP   | Да                          | Да        | Висока        | Облак, много клиенти      |

> **Съвет:** Изборът на правилния транспорт влияе върху производителността, мащабируемостта и потребителското изживяване. **Streamable HTTP** се препоръчва за модерни, мащабируеми и готови за облак приложения.

Обърнете внимание на транспортите stdio и SSE, които бяха разгледани в предишните глави, и как Streamable HTTP е транспортът, разгледан в тази глава.

## Стрийминг: Концепции и мотивация

Разбирането на основните концепции и мотивацията зад стрийминга е от съществено значение за внедряване на ефективни системи за комуникация в реално време.

**Стриймингът** е техника в мрежовото програмиране, която позволява данните да се изпращат и получават на малки, управляеми части или като последователност от събития, вместо да се чака цялостният отговор да бъде готов. Това е особено полезно за:

- Големи файлове или набори от данни.
- Актуализации в реално време (например чат, индикатори за напредък).
- Дълготрайни изчисления, при които искате да информирате потребителя.

Ето какво трябва да знаете за стрийминга на високо ниво:

- Данните се доставят прогресивно, а не наведнъж.
- Клиентът може да обработва данните, докато пристигат.
- Намалява възприеманото закъснение и подобрява потребителското изживяване.

### Защо да използваме стрийминг?

Причините за използване на стрийминг са следните:

- Потребителите получават обратна връзка незабавно, а не само в края.
- Позволява приложения в реално време и отзивчиви интерфейси.
- По-ефективно използване на мрежовите и изчислителните ресурси.

### Прост пример: HTTP стрийминг сървър и клиент

Ето прост пример за това как може да се внедри стрийминг:

#### Python

**Сървър (Python, използвайки FastAPI и StreamingResponse):**

```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import time

app = FastAPI()

async def event_stream():
    for i in range(1, 6):
        yield f"data: Message {i}\n\n"
        time.sleep(1)

@app.get("/stream")
def stream():
    return StreamingResponse(event_stream(), media_type="text/event-stream")
```

**Клиент (Python, използвайки requests):**

```python
import requests

with requests.get("http://localhost:8000/stream", stream=True) as r:
    for line in r.iter_lines():
        if line:
            print(line.decode())
```

Този пример демонстрира сървър, който изпраща серия от съобщения към клиента, докато те стават налични, вместо да чака всички съобщения да бъдат готови.

**Как работи:**

- Сървърът предоставя всяко съобщение, когато е готово.
- Клиентът получава и отпечатва всяка част, докато пристига.

**Изисквания:**

- Сървърът трябва да използва стрийминг отговор (например `StreamingResponse` във FastAPI).
- Клиентът трябва да обработва отговора като поток (`stream=True` в requests).
- Content-Type обикновено е `text/event-stream` или `application/octet-stream`.

#### Java

**Сървър (Java, използвайки Spring Boot и Server-Sent Events):**

```java
@RestController
public class CalculatorController {

    @GetMapping(value = "/calculate", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> calculate(@RequestParam double a,
                                                   @RequestParam double b,
                                                   @RequestParam String op) {
        
        double result;
        switch (op) {
            case "add": result = a + b; break;
            case "sub": result = a - b; break;
            case "mul": result = a * b; break;
            case "div": result = b != 0 ? a / b : Double.NaN; break;
            default: result = Double.NaN;
        }

        return Flux.<ServerSentEvent<String>>just(
                    ServerSentEvent.<String>builder()
                        .event("info")
                        .data("Calculating: " + a + " " + op + " " + b)
                        .build(),
                    ServerSentEvent.<String>builder()
                        .event("result")
                        .data(String.valueOf(result))
                        .build()
                )
                .delayElements(Duration.ofSeconds(1));
    }
}
```

**Клиент (Java, използвайки Spring WebFlux WebClient):**

```java
@SpringBootApplication
public class CalculatorClientApplication implements CommandLineRunner {

    private final WebClient client = WebClient.builder()
            .baseUrl("http://localhost:8080")
            .build();

    @Override
    public void run(String... args) {
        client.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/calculate")
                        .queryParam("a", 7)
                        .queryParam("b", 5)
                        .queryParam("op", "mul")
                        .build())
                .accept(MediaType.TEXT_EVENT_STREAM)
                .retrieve()
                .bodyToFlux(String.class)
                .doOnNext(System.out::println)
                .blockLast();
    }
}
```

**Бележки за Java имплементация:**

- Използва реактивния стек на Spring Boot с `Flux` за стрийминг.
- `ServerSentEvent` предоставя структурирано стрийминг на събития с типове събития.
- `WebClient` с `bodyToFlux()` позволява реактивно потребление на стрийминг.
- `delayElements()` симулира време за обработка между събитията.
- Събитията могат да имат типове (`info`, `result`) за по-добра обработка от клиента.

### Сравнение: Класически стрийминг срещу MCP стрийминг

Разликите между това как стриймингът работи по "класически" начин и как работи в MCP могат да бъдат представени така:

| Характеристика          | Класически HTTP стрийминг      | MCP стрийминг (Известия)          |
|-------------------------|-------------------------------|-----------------------------------|
| Основен отговор         | На части                      | Един, в края                     |
| Актуализации на напредъка | Изпращат се като части от данни | Изпращат се като известия         |
| Изисквания към клиента  | Трябва да обработва потока     | Трябва да внедри обработчик на съобщения |
| Приложение              | Големи файлове, AI токени     | Напредък, логове, обратна връзка в реално време |

### Наблюдавани ключови разлики

Допълнително, ето някои ключови разлики:

- **Модел на комуникация:**
  - Класически HTTP стрийминг: Използва просто кодиране на трансфер на части за изпращане на данни.
  - MCP стрийминг: Използва структурирана система за известия с JSON-RPC протокол.

- **Формат на съобщенията:**
  - Класически HTTP: Обикновени текстови части с нови редове.
  - MCP: Структурирани обекти LoggingMessageNotification с метаданни.

- **Имплементация на клиента:**
  - Класически HTTP: Прост клиент, който обработва стрийминг отговори.
  - MCP: По-сложен клиент с обработчик на съобщения за обработка на различни типове съобщения.

- **Актуализации на напредъка:**
  - Класически HTTP: Напредъкът е част от основния поток на отговор.
  - MCP: Напредъкът се изпраща чрез отделни съобщения за известия, докато основният отговор идва в края.

### Препоръки

Ето някои препоръки при избора между внедряване на класически стрийминг (като крайна точка, която показахме по-горе, използвайки `/stream`) и избора на стрийминг чрез MCP.

- **За прости нужди от стрийминг:** Класическият HTTP стрийминг е по-лесен за внедряване и достатъчен за основни нужди.
- **За сложни, интерактивни приложения:** MCP стриймингът предоставя по-структуриран подход с по-богати метаданни и разделение между известия и крайни резултати.
- **За AI приложения:** Системата за известия на MCP е особено полезна за дълготрайни AI задачи, при които искате да информирате потребителите за напредъка.

## Стрийминг в MCP

Добре, вече видяхте някои препоръки и сравнения относно разликата между класически стрийминг и стрийминг в MCP. Нека разгледаме подробно как точно можете да използвате стрийминг в MCP.

Разбирането на това как стриймингът работи в рамките на MCP е от съществено значение за изграждане на отзивчиви приложения, които предоставят обратна връзка в реално време на потребителите по време на дълготрайни операции.

В MCP стриймингът не е за изпращане на основния отговор на части, а за изпращане на **известия** към клиента, докато инструмент обработва заявка. Тези известия могат да включват актуализации на напредъка, логове или други събития.

### Как работи

Основният резултат все още се изпраща като един отговор. Въпреки това, известията могат да се изпращат като отделни съобщения по време на обработката, като по този начин актуализират клиента в реално време. Клиентът трябва да може да обработва и показва тези известия.
Има две убедителни причини да преминете от SSE към Streamable HTTP:

- Streamable HTTP предлага по-добра мащабируемост, съвместимост и по-богата поддръжка за известия в сравнение със SSE.
- Това е препоръчителният транспорт за нови MCP приложения.

### Стъпки за миграция

Ето как можете да мигрирате от SSE към Streamable HTTP във вашите MCP приложения:

- **Актуализирайте сървърния код**, като използвате `transport="streamable-http"` в `mcp.run()`.
- **Актуализирайте клиентския код**, като използвате `streamablehttp_client` вместо SSE клиент.
- **Реализирайте обработчик на съобщения** в клиента за обработка на известията.
- **Тествайте съвместимостта** със съществуващите инструменти и работни процеси.

### Поддържане на съвместимост

Препоръчително е да поддържате съвместимост със съществуващите SSE клиенти по време на процеса на миграция. Ето някои стратегии:

- Можете да поддържате както SSE, така и Streamable HTTP, като ги стартирате на различни крайни точки.
- Постепенно мигрирайте клиентите към новия транспорт.

### Предизвикателства

Уверете се, че се справяте със следните предизвикателства по време на миграцията:

- Гарантиране, че всички клиенти са актуализирани
- Управление на разликите в доставката на известия

## Съображения за сигурност

Сигурността трябва да бъде основен приоритет при внедряването на сървър, особено когато се използват HTTP-базирани транспорти като Streamable HTTP в MCP.

При внедряване на MCP сървъри с HTTP-базирани транспорти, сигурността става критичен въпрос, който изисква внимателно разглеждане на множество вектори на атака и механизми за защита.

### Преглед

Сигурността е от съществено значение при излагане на MCP сървъри през HTTP. Streamable HTTP въвежда нови повърхности за атака и изисква внимателна конфигурация.

Ето някои ключови съображения за сигурност:

- **Валидиране на Origin хедъра**: Винаги валидирайте хедъра `Origin`, за да предотвратите DNS rebinding атаки.
- **Свързване към localhost**: За локална разработка свържете сървърите към `localhost`, за да избегнете излагането им в публичния интернет.
- **Автентикация**: Реализирайте автентикация (например API ключове, OAuth) за продукционни среди.
- **CORS**: Конфигурирайте политики за Cross-Origin Resource Sharing (CORS), за да ограничите достъпа.
- **HTTPS**: Използвайте HTTPS в продукционна среда за криптиране на трафика.

### Най-добри практики

Освен това, ето някои най-добри практики, които да следвате при внедряване на сигурност във вашия MCP стрийминг сървър:

- Никога не се доверявайте на входящи заявки без валидиране.
- Логвайте и наблюдавайте всички достъпи и грешки.
- Редовно актуализирайте зависимостите, за да отстраните уязвимости в сигурността.

### Предизвикателства

Ще се сблъскате с някои предизвикателства при внедряване на сигурност в MCP стрийминг сървъри:

- Балансиране между сигурност и лекота на разработка
- Гарантиране на съвместимост с различни клиентски среди

### Задача: Създайте собствено стрийминг MCP приложение

**Сценарий:**
Създайте MCP сървър и клиент, където сървърът обработва списък с елементи (например файлове или документи) и изпраща известие за всеки обработен елемент. Клиентът трябва да показва всяко известие в реално време.

**Стъпки:**

1. Реализирайте сървърен инструмент, който обработва списък и изпраща известия за всеки елемент.
2. Реализирайте клиент с обработчик на съобщения, който да показва известията в реално време.
3. Тествайте вашата реализация, като стартирате както сървъра, така и клиента, и наблюдавайте известията.

[Решение](./solution/README.md)

## Допълнителна литература и следващи стъпки

За да продължите своето пътешествие с MCP стрийминг и да разширите знанията си, този раздел предоставя допълнителни ресурси и предложени следващи стъпки за изграждане на по-сложни приложения.

### Допълнителна литература

- [Microsoft: Въведение в HTTP стрийминг](https://learn.microsoft.com/aspnet/core/fundamentals/http-requests?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430#streaming)
- [Microsoft: Server-Sent Events (SSE)](https://learn.microsoft.com/azure/application-gateway/for-containers/server-sent-events?tabs=server-sent-events-gateway-api&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Microsoft: CORS в ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/cors?view=aspnetcore-8.0&WT.mc_id=%3Fwt.mc_id%3DMVP_452430)
- [Python requests: Стрийминг заявки](https://requests.readthedocs.io/en/latest/user/advanced/#streaming-requests)

### Какво следва?

- Опитайте да изградите по-сложни MCP инструменти, които използват стрийминг за анализи в реално време, чат или съвместно редактиране.
- Изследвайте интеграцията на MCP стрийминг с фронтенд рамки (React, Vue и др.) за актуализации на потребителския интерфейс в реално време.
- Следващо: [Използване на AI Toolkit за VSCode](../07-aitk/README.md)

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI услуга за превод [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматичните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия изходен език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален превод от човек. Ние не носим отговорност за каквито и да е недоразумения или погрешни интерпретации, произтичащи от използването на този превод.