<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0a6a7bcb289c024a91289e0444cb370b",
  "translation_date": "2025-08-19T17:15:04+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "sr"
}
-->
# Основни концепти MCP: Савладавање Протокола Контекста Модела за интеграцију вештачке интелигенције

[![Основни концепти MCP](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.sr.png)](https://youtu.be/earDzWGtE84)

_(Кликните на слику изнад да бисте погледали видео лекцију)_

[Model Context Protocol (MCP)](https://gi- **Експлицитна корисничка сагласност**: Сваки приступ подацима и операције захтевају експлицитно одобрење корисника пре извршења. Корисници морају јасно разумети који ће подаци бити приступачни и које ће радње бити извршене, уз детаљну контролу дозвола и овлашћења.

- **Заштита приватности података**: Кориснички подаци се излажу само уз експлицитну сагласност и морају бити заштићени снажним контролама приступа током целог животног циклуса интеракције. Имплементације морају спречити неовлашћен пренос података и одржавати строге границе приватности.

- **Безбедност извршавања алата**: Свака активација алата захтева експлицитну сагласност корисника уз јасно разумевање функционалности алата, параметара и потенцијалног утицаја. Снажне безбедносне границе морају спречити ненамерно, небезбедно или злонамерно извршавање алата.

- **Сигурност транспортног слоја**: Сви комуникациони канали треба да користе одговарајуће механизме за енкрипцију и аутентификацију. Удаљене везе треба да имплементирају сигурне транспортне протоколе и правилно управљање акредитивима.

#### Смернице за имплементацију:

- **Управљање дозволама**: Имплементирајте систем дозвола са детаљним подешавањима који омогућавају корисницима да контролишу којим серверима, алатима и ресурсима се може приступити  
- **Аутентификација и овлашћење**: Користите сигурне методе аутентификације (OAuth, API кључеви) са правилним управљањем токенима и њиховим истеком  
- **Валидација уноса**: Проверавајте све параметре и уносе података у складу са дефинисаним шемама како бисте спречили нападе убризгавањем  
- **Евидентирање активности**: Одржавајте свеобухватне записе свих операција ради праћења безбедности и усклађености  

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/specification/2025-06-18/) је моћан, стандардизован оквир који оптимизује комуникацију између великих језичких модела (LLMs) и спољашњих алата, апликација и извора података. Овај водич ће вас провести кроз основне концепте MCP-а, осигуравајући да разумете његову клијент-сервер архитектуру, кључне компоненте, механизме комуникације и најбоље праксе имплементације.

## Преглед

Ова лекција истражује основну архитектуру и компоненте које чине екосистем Model Context Protocol-а (MCP). Научићете о клијент-сервер архитектури, кључним компонентама и механизмима комуникације који покрећу MCP интеракције.

## Кључни циљеви учења

До краја ове лекције, моћи ћете да:

- Разумете MCP клијент-сервер архитектуру.  
- Идентификујете улоге и одговорности домаћина, клијената и сервера.  
- Анализирате основне карактеристике које чине MCP флексибилним слојем за интеграцију.  
- Научите како информације теку унутар MCP екосистема.  
- Стекнете практичне увиде кроз примере кода у .NET, Java, Python и JavaScript језицима.  

## MCP архитектура: Детаљнији поглед

Екосистем MCP-а је изграђен на клијент-сервер моделу. Ова модуларна структура омогућава AI апликацијама да ефикасно комуницирају са алатима, базама података, API-јевима и контекстуалним ресурсима. Хајде да разложимо ову архитектуру на њене основне компоненте.

У својој суштини, MCP прати клијент-сервер архитектуру где хост апликација може да се повеже са више сервера:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP домаћини**: Програми као што су VSCode, Claude Desktop, IDE-ови или AI алати који желе да приступе подацима преко MCP-а  
- **MCP клијенти**: Протокол клијенти који одржавају 1:1 везе са серверима  
- **MCP сервери**: Лагани програми који излажу специфичне могућности кроз стандардизовани Model Context Protocol  
- **Локални извори података**: Фајлови, базе података и услуге на вашем рачунару којима MCP сервери могу безбедно приступити  
- **Удаљене услуге**: Спољашњи системи доступни преко интернета којима MCP сервери могу приступити преко API-ја.  

MCP протокол је еволутивни стандард који користи верзионисање засновано на датуму (формат YYYY-MM-DD). Тренутна верзија протокола је **2025-06-18**. Најновије ажурирања спецификације протокола можете видети [овде](https://modelcontextprotocol.io/specification/2025-06-18/).

### 1. Домаћини

У Model Context Protocol-у (MCP), **домаћини** су AI апликације које служе као примарни интерфејс преко којег корисници комуницирају са протоколом. Домаћини координишу и управљају везама са више MCP сервера креирањем посебних MCP клијената за сваку серверску везу. Примери домаћина укључују:

- **AI апликације**: Claude Desktop, Visual Studio Code, Claude Code  
- **Развојна окружења**: IDE-ови и уређивачи кода са MCP интеграцијом  
- **Прилагођене апликације**: Специјализовани AI агенти и алати  

**Домаћини** су апликације које координишу интеракције са AI моделима. Они:

- **Организују AI моделе**: Извршавају или комуницирају са LLM-овима ради генерисања одговора и координације AI токова рада  
- **Управљају клијентским везама**: Креирају и одржавају једног MCP клијента по MCP серверској вези  
- **Контролишу кориснички интерфејс**: Управљају током разговора, интеракцијама са корисником и приказом одговора  
- **Спроводе безбедност**: Контролишу дозволе, безбедносна ограничења и аутентификацију  
- **Управљају корисничком сагласношћу**: Обезбеђују одобрење корисника за дељење података и извршавање алата  

### 2. Клијенти

**Клијенти** су суштинске компоненте које одржавају посебне један-на-један везе између домаћина и MCP сервера. Сваки MCP клијент је инстанциран од стране домаћина ради повезивања са одређеним MCP сервером, осигуравајући организоване и безбедне комуникационе канале. Више клијената омогућава домаћинима да се истовремено повежу са више сервера.

**Клијенти** су конекторске компоненте унутар домаћинске апликације. Они:

- **Комуникација протокола**: Шаљу JSON-RPC 2.0 захтеве серверима са упутствима и промптовима  
- **Преговарање могућности**: Преговарају о подржаним функцијама и верзијама протокола са серверима током иницијализације  
- **Извршавање алата**: Управљају захтевима за извршавање алата од модела и обрађују одговоре  
- **Ажурирања у реалном времену**: Обрађују обавештења и ажурирања у реалном времену од сервера  
- **Обрада одговора**: Обрађују и форматирају одговоре сервера за приказ корисницима  

### 3. Сервери

**Сервери** су програми који пружају контекст, алате и могућности MCP клијентима. Они могу бити извршени локално (на истом рачунару као домаћин) или удаљено (на спољашњим платформама) и одговорни су за обраду захтева клијената и пружање структуираних одговора. Сервери излажу специфичну функционалност кроз стандардизовани Model Context Protocol.

**Сервери** су услуге које пружају контекст и могућности. Они:

- **Регистрација функција**: Региструју и излажу доступне примитиве (ресурсе, промптове, алате) клијентима  
- **Обрада захтева**: Примају и извршавају позиве алата, захтеве за ресурсима и промптовима од клијената  
- **Пружање контекста**: Пружају контекстуалне информације и податке ради побољшања одговора модела  
- **Управљање стањем**: Одржавају стање сесије и обрађују интеракције са стањем када је потребно  
- **Обавештења у реалном времену**: Шаљу обавештења о променама могућности и ажурирањима повезаним клијентима  

Сервери могу бити развијени од стране било кога ради проширења могућности модела специјализованом функционалношћу и подржавају како локалне тако и удаљене сценарије распоређивања.  

### 4. Примитиве сервера

Сервери у Model Context Protocol-у (MCP) пружају три основне **примитиве** које дефинишу основне грађевинске блокове за богате интеракције између клијената, домаћина и језичких модела. Ове примитиве одређују врсте контекстуалних информација и радњи доступних кроз протокол.

MCP сервери могу излагати било коју комбинацију следеће три основне примитиве:

#### Ресурси

**Ресурси** су извори података који пружају контекстуалне информације AI апликацијама. Они представљају статички или динамички садржај који може побољшати разумевање и доношење одлука модела:

- **Контекстуални подаци**: Структурисане информације и контекст за конзумацију AI модела  
- **Базе знања**: Репозиторијуми докумената, чланци, приручници и истраживачки радови  
- **Локални извори података**: Фајлови, базе података и информације локалног система  
- **Спољашњи подаци**: Одговори API-ја, веб услуге и подаци удаљених система  
- **Динамички садржај**: Подаци у реалном времену који се ажурирају на основу спољашњих услова  

Ресурси се идентификују URI-јевима и подржавају откривање кроз методе `resources/list` и преузимање кроз `resources/read`:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### Промптови

**Промптови** су поново употребљиви шаблони који помажу у структуирању интеракција са језичким моделима. Они пружају стандардизоване обрасце интеракције и шаблоне токова рада:

- **Интеракције засноване на шаблонима**: Унапред структуиране поруке и почетни разговори  
- **Шаблони токова рада**: Стандардизовани низови за уобичајене задатке и интеракције  
- **Примери Few-shot**: Шаблони засновани на примерима за инструкције моделу  
- **Системски промптови**: Основни промптови који дефинишу понашање и контекст модела  
- **Динамички шаблони**: Параметризовани промптови који се прилагођавају специфичним контекстима  

Промптови подржавају замену променљивих и могу се открити преко `prompts/list` и преузети са `prompts/get`:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### Алати

**Алати** су извршиве функције које AI модели могу позвати ради извршавања специфичних радњи. Они представљају "глаголе" MCP екосистема, омогућавајући моделима да комуницирају са спољашњим системима:

- **Извршиве функције**: Дискретне операције које модели могу позвати са специфичним параметрима  
- **Интеграција спољашњих система**: Позиви API-ја, упити база података, операције са фајловима, прорачуни  
- **Јединствени идентитет**: Сваки алат има јединствено име, опис и шему параметара  
- **Структурисани улаз/излаз**: Алати прихватају валидиране параметре и враћају структурисане, типизиране одговоре  
- **Могућности акције**: Омогућавају моделима да извршавају радње у стварном свету и добијају актуелне податке  

Алати су дефинисани JSON шемом за валидацију параметара и откривају се преко `tools/list` и извршавају преко `tools/call`:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## Примитиве клијената

У Model Context Protocol-у (MCP), **клијенти** могу излагати примитиве које омогућавају серверима да захтевају додатне могућности од домаћинске апликације. Ове примитиве на страни клијента омогућавају богатије, интерактивније имплементације сервера које могу приступити могућностима AI модела и интеракцијама са корисником.

### Узорковање

**Узорковање** омогућава серверима да захтевају завршетке језичког модела од AI апликације клијента. Ова примитива омогућава серверима приступ LLM могућностима без уграђивања сопствених зависности модела:

- **Приступ независан од модела**: Сервери могу захтевати завршетке без укључивања LLM SDK-ова или управљања приступом моделу  
- **AI иницијатива сервера**: Омогућава серверима да аутономно генеришу садржај користећи AI модел клијента  
- **Рекурзивне LLM интеракције**: Подржава сложене сценарије где серверима треба AI помоћ за обраду  
- **Генерисање динамичког садржаја**: Омогућава серверима да креирају контекстуалне одговоре користећи модел домаћина  

Узорковање се иницира преко методе `sampling/complete`, где сервери шаљу захтеве за завршетке клијентима.

### Елицитација  

**Елицитација** омогућава серверима да захтевају додатне информације или потврду од корисника преко интерфејса клијента:

- **Захтеви за унос корисника**: Сервери могу тражити додатне информације када су потребне за извршавање алата  
- **Дијалози за потврду**
- **Управљање животним циклусом**: Обухвата иницијализацију везе, преговарање о могућностима и завршетак сесије између клијената и сервера  
- **Примитиви сервера**: Омогућава серверима да пруже основну функционалност кроз алате, ресурсе и шаблоне  
- **Примитиви клијента**: Омогућава серверима да захтевају узорковање од LLM-ова, прикупљају унос корисника и шаљу поруке у дневник  
- **Обавештења у реалном времену**: Подржава асинхрона обавештења за динамичка ажурирања без потребе за учесталим проверама  

#### Кључне карактеристике:

- **Преговарање о верзији протокола**: Користи верзионисање засновано на датуму (ГГГГ-ММ-ДД) ради осигурања компатибилности  
- **Откривање могућности**: Клијенти и сервери размењују информације о подржаним функцијама током иницијализације  
- **Сесије са стањем**: Одржава стање везе током више интеракција ради континуитета контекста  

### Транспортни слој

**Транспортни слој** управља комуникационим каналима, форматирањем порука и аутентификацијом између MCP учесника:

#### Подржани транспортни механизми:

1. **STDIO транспорт**:  
   - Користи стандардне улазно/излазне токове за директну комуникацију процеса  
   - Оптималан за локалне процесе на истој машини без мрежног оптерећења  
   - Често се користи за локалне MCP серверске имплементације  

2. **Стримујући HTTP транспорт**:  
   - Користи HTTP POST за поруке од клијента ка серверу  
   - Опционо Server-Sent Events (SSE) за стримовање од сервера ка клијенту  
   - Омогућава комуникацију са удаљеним серверима преко мрежа  
   - Подржава стандардну HTTP аутентификацију (токени, API кључеви, прилагођени заглавља)  
   - MCP препоручује OAuth за сигурну аутентификацију засновану на токенима  

#### Апстракција транспорта:

Транспортни слој апстрахује детаље комуникације од слоја података, омогућавајући исти JSON-RPC 2.0 формат порука за све транспортне механизме. Ова апстракција омогућава апликацијама да лако прелазе између локалних и удаљених сервера.

### Безбедносни аспекти

MCP имплементације морају се придржавати неколико критичних безбедносних принципа како би осигурале сигурне, поуздане и безбедне интеракције у свим операцијама протокола:

- **Сагласност и контрола корисника**: Корисници морају дати експлицитну сагласност пре приступа подацима или извршавања операција. Треба да имају јасну контролу над тим који подаци се деле и које акције су овлашћене, уз интуитивне интерфејсе за преглед и одобравање активности.

- **Приватност података**: Кориснички подаци треба да буду изложени само уз експлицитну сагласност и морају бити заштићени одговарајућим контролама приступа. MCP имплементације морају спречити неовлашћен пренос података и осигурати да приватност буде очувана током свих интеракција.

- **Безбедност алата**: Пре позивања било ког алата, потребна је експлицитна сагласност корисника. Корисници треба да имају јасно разумевање функционалности сваког алата, а морају се спровести робусне безбедносне границе како би се спречило ненамерно или небезбедно извршавање алата.

Придржавањем ових безбедносних принципа, MCP осигурава да се поверење, приватност и безбедност корисника одржавају у свим интеракцијама протокола, уз омогућавање моћних интеграција са AI.

## Примери кода: Кључне компоненте

Испод су примери кода на неколико популарних програмских језика који илуструју како имплементирати кључне MCP серверске компоненте и алате.

### .NET пример: Креирање једноставног MCP сервера са алатима

Ово је практичан .NET пример кода који демонстрира како имплементирати једноставан MCP сервер са прилагођеним алатима. Пример показује како дефинисати и регистровати алате, обрађивати захтеве и повезати сервер користећи Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Java пример: Компоненте MCP сервера

Овај пример демонстрира исти MCP сервер и регистрацију алата као горњи .NET пример, али имплементиран у Java.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Python пример: Изградња MCP сервера

У овом примеру показујемо како изградити MCP сервер у Python-у. Такође су приказана два различита начина за креирање алата.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### JavaScript пример: Креирање MCP сервера

Овај пример показује креирање MCP сервера у JavaScript-у и како регистровати два алата повезана са временским условима.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Овај JavaScript пример демонстрира како креирати MCP клијента који се повезује са сервером, шаље упит и обрађује одговор, укључујући све позиве алата који су направљени.

## Безбедност и овлашћење

MCP укључује неколико уграђених концепата и механизама за управљање безбедношћу и овлашћењем током протокола:

1. **Контрола дозвола за алате**:  
   Клијенти могу одредити који алати су дозвољени моделу током сесије. Ово осигурава да су доступни само експлицитно овлашћени алати, смањујући ризик од ненамерних или небезбедних операција. Дозволе се могу динамички конфигурисати на основу корисничких преференција, организационих политика или контекста интеракције.

2. **Аутентификација**:  
   Сервери могу захтевати аутентификацију пре него што одобре приступ алатима, ресурсима или осетљивим операцијама. Ово може укључивати API кључеве, OAuth токене или друге шеме аутентификације. Правилна аутентификација осигурава да само поуздани клијенти и корисници могу позивати серверске могућности.

3. **Валидација**:  
   Валидација параметара се спроводи за све позиве алата. Сваки алат дефинише очекиване типове, формате и ограничења за своје параметре, а сервер валидира долазне захтеве у складу с тим. Ово спречава да неисправан или злонамеран унос стигне до имплементације алата и помаже у одржавању интегритета операција.

4. **Ограничење брзине**:  
   Да би се спречила злоупотреба и осигурало правично коришћење серверских ресурса, MCP сервери могу имплементирати ограничење брзине за позиве алата и приступ ресурсима. Ограничења брзине могу се применити по кориснику, по сесији или глобално, и помажу у заштити од напада ускраћивања услуге или прекомерне потрошње ресурса.

Комбинујући ове механизме, MCP пружа сигурну основу за интеграцију језичких модела са спољним алатима и изворима података, уз давање корисницима и програмерима детаљне контроле над приступом и употребом.

## Поруке протокола и ток комуникације

MCP комуникација користи структуриране **JSON-RPC 2.0** поруке за олакшавање јасних и поузданих интеракција између домаћина, клијената и сервера. Протокол дефинише специфичне обрасце порука за различите типове операција:

### Основни типови порука:

#### **Поруке иницијализације**  
- **`initialize` Захтев**: Успоставља везу и преговара о верзији протокола и могућностима  
- **`initialize` Одговор**: Потврђује подржане функције и информације о серверу  
- **`notifications/initialized`**: Сигнализира да је иницијализација завршена и да је сесија спремна  

#### **Поруке откривања**  
- **`tools/list` Захтев**: Открива доступне алате са сервера  
- **`resources/list` Захтев**: Наводи доступне ресурсе (изворе података)  
- **`prompts/list` Захтев**: Преузима доступне шаблоне упита  

#### **Поруке извршења**  
- **`tools/call` Захтев**: Извршава одређени алат са датим параметрима  
- **`resources/read` Захтев**: Преузима садржај из одређеног ресурса  
- **`prompts/get` Захтев**: Преузима шаблон упита са опционим параметрима  

#### **Поруке на страни клијента**  
- **`sampling/complete` Захтев**: Сервер захтева завршетак LLM-а од клијента  
- **`elicitation/request`**: Сервер захтева унос корисника преко интерфејса клијента  
- **Поруке дневника**: Сервер шаље структуриране поруке дневника клијенту  

#### **Поруке обавештења**  
- **`notifications/tools/list_changed`**: Сервер обавештава клијента о променама алата  
- **`notifications/resources/list_changed`**: Сервер обавештава клијента о променама ресурса  
- **`notifications/prompts/list_changed`**: Сервер обавештава клијента о променама шаблона  

### Структура порука:

Све MCP поруке следе JSON-RPC 2.0 формат са:  
- **Захтевима**: Укључују `id`, `method` и опционе `params`  
- **Одговорима**: Укључују `id` и или `result` или `error`  
- **Обавештењима**: Укључују `method` и опционе `params` (без `id` или очекиваног одговора)  

Ова структурирана комуникација осигурава поуздане, пратеће и прошириве интеракције које подржавају напредне сценарије као што су ажурирања у реалном времену, ланци алата и робусно руковање грешкама.

## Кључни закључци

- **Архитектура**: MCP користи архитектуру клијент-сервер где домаћини управљају више клијентских веза са серверима  
- **Учесници**: Екосистем укључује домаћине (AI апликације), клијенте (конектори протокола) и сервере (пружаоце могућности)  
- **Транспортни механизми**: Комуникација подржава STDIO (локално) и стримујући HTTP са опционим SSE (удаљено)  
- **Основни примитиви**: Сервери излажу алате (извршиве функције), ресурсе (изворе података) и шаблоне (упите)  
- **Примитиви клијента**: Сервери могу захтевати узорковање (LLM завршетке), прикупљање (унос корисника) и дневнике од клијената  
- **Основа протокола**: Заснован на JSON-RPC 2.0 са верзионисањем заснованим на датуму (тренутно: 2025-06-18)  
- **Могућности у реалном времену**: Подржава обавештења за динамичка ажурирања и синхронизацију у реалном времену  
- **Безбедност на првом месту**: Експлицитна сагласност корисника, заштита приватности података и сигуран транспорт су основни захтеви  

## Вежба

Дизајнирајте једноставан MCP алат који би био користан у вашој области. Дефинишите:  
1. Како би се алат звао  
2. Које параметре би прихватао  
3. Који излаз би враћао  
4. Како би модел могао да користи овај алат за решавање проблема корисника  

---

## Шта следи

Следеће: [Поглавље 2: Безбедност](../02-Security/README.md)  

**Одрицање од одговорности**:  
Овај документ је преведен коришћењем услуге за превођење помоћу вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако се трудимо да обезбедимо тачност, молимо вас да имате у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на његовом изворном језику треба сматрати меродавним извором. За критичне информације препоручује се професионални превод од стране људи. Не преузимамо одговорност за било каква погрешна тумачења или неспоразуме који могу настати услед коришћења овог превода.