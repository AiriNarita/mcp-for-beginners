<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "88b863a69b4f18b15e82da358ffd3489",
  "translation_date": "2025-08-21T13:49:59+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "sr"
}
-->
# Основни концепти MCP: Савладавање Протокола Контекста Модела за интеграцију вештачке интелигенције

[![Основни концепти MCP](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.sr.png)](https://youtu.be/earDzWGtE84)

_(Кликните на слику изнад да бисте погледали видео лекцију)_

[Model Context Protocol (MCP)](https://github.com/modelcontextprotocol) је моћан, стандардизован оквир који оптимизује комуникацију између великих језичких модела (LLMs) и спољашњих алата, апликација и извора података.  
Овај водич ће вас провести кроз основне концепте MCP-а. Научићете о његовој клијент-сервер архитектури, кључним компонентама, механизмима комуникације и најбољим праксама за имплементацију.

- **Експлицитна сагласност корисника**: Сваки приступ подацима и операције захтевају експлицитно одобрење корисника пре извршења. Корисници морају јасно разумети који ће подаци бити приступачни и које ће радње бити извршене, уз детаљну контролу над дозволама и овлашћењима.

- **Заштита приватности података**: Кориснички подаци се излажу само уз експлицитну сагласност и морају бити заштићени робусним контролама приступа током целог животног циклуса интеракције. Имплементације морају спречити неовлашћен пренос података и одржавати строге границе приватности.

- **Безбедност извршавања алата**: Свака активација алата захтева експлицитну сагласност корисника уз јасно разумевање функционалности алата, параметара и потенцијалног утицаја. Робусне безбедносне границе морају спречити ненамерно, небезбедно или злонамерно извршавање алата.

- **Безбедност транспортног слоја**: Сви комуникациони канали треба да користе одговарајуће механизме за шифровање и аутентификацију. Удаљене везе треба да имплементирају безбедне транспортне протоколе и правилно управљање акредитивима.

#### Упутства за имплементацију:

- **Управљање дозволама**: Имплементирајте систем дозвола са детаљном контролом који омогућава корисницима да одреде којим серверима, алатима и ресурсима се може приступити  
- **Аутентификација и овлашћење**: Користите безбедне методе аутентификације (OAuth, API кључеве) са правилним управљањем токенима и њиховим истеком  
- **Валидација уноса**: Проверавајте све параметре и уносе података према дефинисаним шемама како бисте спречили нападе убризгавањем  
- **Аудит логови**: Одржавајте свеобухватне записе свих операција ради праћења безбедности и усклађености

## Преглед

Ова лекција истражује основну архитектуру и компоненте које чине екосистем Model Context Protocol (MCP). Научићете о клијент-сервер архитектури, кључним компонентама и механизмима комуникације који покрећу MCP интеракције.

## Кључни циљеви учења

До краја ове лекције, моћи ћете да:

- Разумете MCP клијент-сервер архитектуру.  
- Идентификујете улоге и одговорности Хостова, Клијената и Сервера.  
- Анализирате основне карактеристике које MCP чине флексибилним слојем за интеграцију.  
- Научите како информације протичу унутар MCP екосистема.  
- Стекнете практична знања кроз примере кода у .NET, Java, Python и JavaScript.

## MCP архитектура: Детаљнији поглед

Екосистем MCP је изграђен на клијент-сервер моделу. Ова модуларна структура омогућава AI апликацијама да ефикасно комуницирају са алатима, базама података, API-јевима и контекстуалним ресурсима. Хајде да разложимо ову архитектуру на њене основне компоненте.

У својој суштини, MCP прати клијент-сервер архитектуру где хост апликација може да се повеже са више сервера:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP Хостови**: Програми као што су VSCode, Claude Desktop, IDE-ови или AI алати који желе да приступе подацима преко MCP-а  
- **MCP Клијенти**: Протокол клијенти који одржавају 1:1 везе са серверима  
- **MCP Сервери**: Лагани програми који излажу специфичне могућности кроз стандардизован MCP  
- **Локални извори података**: Фајлови, базе података и услуге на вашем рачунару којима MCP сервери могу безбедно приступити  
- **Удаљене услуге**: Спољашњи системи доступни преко интернета којима MCP сервери могу приступити преко API-ја.

MCP протокол је еволутивни стандард који користи верзионисање засновано на датуму (YYYY-MM-DD формат). Тренутна верзија протокола је **2025-06-18**. Најновија ажурирања спецификације протокола можете видети [овде](https://modelcontextprotocol.io/specification/2025-06-18/).

### 1. Хостови

У Model Context Protocol (MCP), **Хостови** су AI апликације које служе као примарни интерфејс преко којег корисници комуницирају са протоколом. Хостови координишу и управљају везама са више MCP сервера креирањем посебних MCP клијената за сваку серверску везу. Примери Хостова укључују:

- **AI апликације**: Claude Desktop, Visual Studio Code, Claude Code  
- **Развојна окружења**: IDE-ови и едитори кода са MCP интеграцијом  
- **Прилагођене апликације**: Специјализовани AI агенти и алати  

**Хостови** су апликације које координишу интеракције AI модела. Они:

- **Оркестрирају AI моделе**: Извршавају или комуницирају са LLM-овима ради генерисања одговора и координације AI токова рада  
- **Управљају клијентским везама**: Креирају и одржавају једног MCP клијента по MCP серверској вези  
- **Контролишу кориснички интерфејс**: Управљају током разговора, интеракцијама са корисником и приказом одговора  
- **Спроводе безбедност**: Контролишу дозволе, безбедносна ограничења и аутентификацију  
- **Рукују корисничком сагласношћу**: Управљају одобрењем корисника за дељење података и извршавање алата  

### 2. Клијенти

**Клијенти** су суштинске компоненте које одржавају посебне један-на-један везе између Хостова и MCP сервера. Сваки MCP клијент је инстанциран од стране Хоста да би се повезао са одређеним MCP сервером, обезбеђујући организоване и безбедне комуникационе канале. Више клијената омогућава Хостовима да се истовремено повежу са више сервера.

**Клијенти** су конекторске компоненте унутар хост апликације. Они:

- **Комуникација протокола**: Шаљу JSON-RPC 2.0 захтеве серверима са упутствима и инструкцијама  
- **Преговарање могућности**: Преговарају о подржаним функцијама и верзијама протокола са серверима током иницијализације  
- **Извршавање алата**: Управљају захтевима за извршавање алата од модела и обрађују одговоре  
- **Ажурирања у реалном времену**: Рукују обавештењима и ажурирањима у реалном времену од сервера  
- **Обрада одговора**: Обрађују и форматирају одговоре сервера за приказ корисницима  

### 3. Сервери

**Сервери** су програми који пружају контекст, алате и могућности MCP клијентима. Они могу бити извршени локално (на истом рачунару као и Хост) или удаљено (на спољашњим платформама), и одговорни су за руковање захтевима клијената и пружање структуираних одговора. Сервери излажу специфичну функционалност кроз стандардизован Model Context Protocol.

**Сервери** су услуге које пружају контекст и могућности. Они:

- **Регистрација функција**: Региструју и излажу доступне примитиве (ресурсе, упите, алате) клијентима  
- **Обрада захтева**: Примају и извршавају позиве алата, захтеве за ресурсима и упите од клијената  
- **Пружање контекста**: Пружају контекстуалне информације и податке за побољшање одговора модела  
- **Управљање стањем**: Одржавају стање сесије и рукују интеракцијама које захтевају стање када је потребно  
- **Обавештења у реалном времену**: Шаљу обавештења о променама могућности и ажурирањима повезаним клијентима  

Сервери могу бити развијени од стране било кога како би проширили могућности модела специјализованом функционалношћу, и подржавају и локалне и удаљене сценарије примене.

### 4. Примитиви сервера

Сервери у Model Context Protocol (MCP) пружају три основна **примитива** која дефинишу основне грађевинске блокове за богате интеракције између клијената, хостова и језичких модела. Ови примитиви одређују типове контекстуалних информација и радњи доступних кроз протокол.

MCP сервери могу излагати било коју комбинацију следећих три основна примитива:

#### Ресурси

**Ресурси** су извори података који пружају контекстуалне информације AI апликацијама. Они представљају статички или динамички садржај који може побољшати разумевање и доношење одлука модела:

- **Контекстуални подаци**: Структурисане информације и контекст за AI модел  
- **Базе знања**: Репозиторијуми докумената, чланци, приручници и истраживачки радови  
- **Локални извори података**: Фајлови, базе података и информације локалног система  
- **Спољашњи подаци**: Одговори API-ја, веб услуге и подаци удаљених система  
- **Динамички садржај**: Подаци у реалном времену који се ажурирају на основу спољашњих услова  

Ресурси се идентификују URI-јевима и подржавају откривање преко `resources/list` и преузимање преко `resources/read` метода:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### Упити

**Упити** су поновљиви шаблони који помажу у структуирању интеракција са језичким моделима. Они пружају стандардизоване обрасце интеракције и шаблоне токова рада:

- **Интеракције засноване на шаблонима**: Унапред структуиране поруке и почетни упити  
- **Шаблони токова рада**: Стандардизовани низови за уобичајене задатке и интеракције  
- **Примери Few-shot**: Шаблони засновани на примерима за инструкције моделу  
- **Системски упити**: Основни упити који дефинишу понашање и контекст модела  
- **Динамички шаблони**: Параметризовани упити који се прилагођавају специфичним контекстима  

Упити подржавају замену променљивих и могу се открити преко `prompts/list` и преузети са `prompts/get`:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### Алати

**Алати** су извршиве функције које AI модели могу позвати ради извршења специфичних радњи. Они представљају "глаголе" MCP екосистема, омогућавајући моделима да комуницирају са спољашњим системима:

- **Извршиве функције**: Дискретне операције које модели могу позвати са специфичним параметрима  
- **Интеграција спољашњих система**: Позиви API-ја, упити база података, операције над фајловима, прорачуни  
- **Јединствени идентитет**: Сваки алат има јединствено име, опис и шему параметара  
- **Структурисани улаз/излаз**: Алати прихватају валидиране параметре и враћају структурисане, типизиране одговоре  
- **Могућности акције**: Омогућавају моделима да извршавају радње у стварном свету и добијају актуелне податке  

Алати су дефинисани JSON шемом за валидацију параметара и откривају се преко `tools/list` и извршавају преко `tools/call`:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## Примитиви клијената

У Model Context Protocol (MCP), **клијенти** могу излагати примитиве који омогућавају серверима да захтевају додатне могућности од хост апликације. Ови примитиви на страни клијента омогућавају богатије, интерактивније имплементације сервера које могу приступити могућностима AI модела и интеракцијама са корисником.

### Узорковање

**Узорковање** омогућава серверима да захтевају завршетке језичког модела од AI апликације клијента. Овај примитив омогућава серверима приступ LLM могућностима без уграђивања сопствених зависности модела:

- **Приступ независан од модела**: Сервери могу захтевати завршетке без укључивања LLM SDK-ова или управљања приступом моделу  
- **AI иницијатива сервера**: Омогућава серверима да аутономно генеришу садржај користећи AI модел клијента  
- **Рекурзивне LLM интеракције**: Подржава сложене сценарије где серверима треба AI помоћ за обраду  
- **Генерисање динамичког садржаја**: Омогућава серверима да креирају контекстуалне одговоре користећи модел хоста  

Узорковање се иницира преко `sampling/complete` методе, где сервери шаљу захтеве за завршетке клијентима.

### Елицитација  

**Елицитација** омогућава серверима да захтевају додатне информације или потврду од корисника преко интерфејса клијента:

- **Захтеви за унос корисника**: Сервери могу тражити додатне информације када су потребне за извршење алата  
- **Дијалози за потврду**: Захтевају одобрење корисника за осетљиве или утицајне операције  
- **Интерактивни токови рада**: Омогућавају серверима да креирају корак-по-корак интеракције са корисником  
- **Динамичко прикупљање параметара**:
- **JSON-RPC 2.0 Протокол**: Сва комуникација користи стандардизовани JSON-RPC 2.0 формат порука за позиве метода, одговоре и обавештења  
- **Управљање животним циклусом**: Обрађује иницијализацију везе, преговарање о могућностима и завршетак сесије између клијената и сервера  
- **Серверски примитиви**: Омогућава серверима да пружају основну функционалност кроз алате, ресурсе и шаблоне  
- **Клијентски примитиви**: Омогућава серверима да захтевају узорковање од LLM-ова, траже унос од корисника и шаљу поруке у дневник  
- **Обавештења у реалном времену**: Подржава асинхрона обавештења за динамичка ажурирања без потребе за честим проверама  

#### Кључне карактеристике:

- **Преговарање о верзији протокола**: Користи верзионисање засновано на датуму (ГГГГ-ММ-ДД) ради осигурања компатибилности  
- **Откривање могућности**: Клијенти и сервери размењују информације о подржаним функцијама током иницијализације  
- **Сесије са стањем**: Одржава стање везе током више интеракција ради континуитета контекста  

### Транспортни слој

**Транспортни слој** управља комуникационим каналима, форматирањем порука и аутентификацијом између MCP учесника:

#### Подржани транспортни механизми:

1. **STDIO транспорт**:
   - Користи стандардне улазно/излазне токове за директну комуникацију процеса  
   - Оптималан за локалне процесе на истој машини без мрежног оптерећења  
   - Често се користи за локалне имплементације MCP сервера  

2. **Стримујући HTTP транспорт**:
   - Користи HTTP POST за поруке од клијента ка серверу  
   - Опционо Server-Sent Events (SSE) за стримовање од сервера ка клијенту  
   - Омогућава комуникацију са удаљеним серверима преко мрежа  
   - Подржава стандардну HTTP аутентификацију (токени, API кључеви, прилагођени хедери)  
   - MCP препоручује OAuth за сигурну аутентификацију засновану на токенима  

#### Апстракција транспорта:

Транспортни слој апстрахује детаље комуникације од слоја података, омогућавајући исти JSON-RPC 2.0 формат порука за све транспортне механизме. Ова апстракција омогућава апликацијама да лако прелазе између локалних и удаљених сервера.

### Безбедносни аспекти

MCP имплементације морају поштовати неколико кључних безбедносних принципа како би осигурале сигурне, поуздане и безбедне интеракције у свим операцијама протокола:

- **Пристанак и контрола корисника**: Корисници морају дати изричиту сагласност пре приступа подацима или извршавања операција. Требало би да имају јасну контролу над тим који подаци се деле и које акције су одобрене, уз подршку интуитивних интерфејса за преглед и одобравање активности.  

- **Приватност података**: Кориснички подаци могу бити изложени само уз изричиту сагласност и морају бити заштићени одговарајућим контролама приступа. MCP имплементације морају спречити неовлашћен пренос података и осигурати да се приватност одржава током свих интеракција.  

- **Безбедност алата**: Пре позивања било ког алата, потребна је изричита сагласност корисника. Корисници треба да имају јасно разумевање функционалности сваког алата, а морају се спровести робусне безбедносне границе како би се спречило ненамерно или небезбедно извршавање алата.  

Придржавањем ових безбедносних принципа, MCP осигурава да се поверење корисника, приватност и безбедност одржавају у свим интеракцијама протокола, истовремено омогућавајући моћне интеграције са вештачком интелигенцијом.

## Примери кода: Кључне компоненте

Испод су примери кода на неколико популарних програмских језика који илуструју како имплементирати кључне компоненте и алате MCP сервера.

### .NET Пример: Креирање једноставног MCP сервера са алатима

Ово је практичан пример кода на .NET-у који демонстрира како имплементирати једноставан MCP сервер са прилагођеним алатима. Пример приказује како дефинисати и регистровати алате, обрађивати захтеве и повезати сервер користећи Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Java Пример: Компоненте MCP сервера

Овај пример демонстрира исти MCP сервер и регистрацију алата као у .NET примеру изнад, али имплементиран у Јави.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Python Пример: Изградња MCP сервера

У овом примеру приказујемо како изградити MCP сервер у Пајтону. Такође су приказана два различита начина за креирање алата.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### JavaScript Пример: Креирање MCP сервера

Овај пример приказује креирање MCP сервера у ЈаваСкрипту и како регистровати два алата повезана са временским условима.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Овај ЈаваСкрипт пример демонстрира како креирати MCP клијент који се повезује са сервером, шаље упит и обрађује одговор укључујући позиве алата који су извршени.

## Безбедност и ауторизација

MCP укључује неколико уграђених концепата и механизама за управљање безбедношћу и ауторизацијом током целог протокола:

1. **Контрола дозвола за алате**:  
   Клијенти могу одредити које алате модел сме да користи током сесије. Ово осигурава да су доступни само изричито одобрени алати, смањујући ризик од ненамерних или небезбедних операција. Дозволе се могу динамички конфигурисати на основу корисничких преференција, организационих политика или контекста интеракције.  

2. **Аутентификација**:  
   Сервери могу захтевати аутентификацију пре него што одобре приступ алатима, ресурсима или осетљивим операцијама. Ово може укључивати API кључеве, OAuth токене или друге шеме аутентификације. Правилна аутентификација осигурава да само поуздани клијенти и корисници могу позивати серверске могућности.  

3. **Валидација**:  
   Валидација параметара се спроводи за све позиве алата. Сваки алат дефинише очекиване типове, формате и ограничења за своје параметре, а сервер валидацију захтева у складу с тим. Ово спречава да неисправан или злонамеран унос дође до имплементације алата и помаже у одржавању интегритета операција.  

4. **Ограничење брзине**:  
   Да би се спречила злоупотреба и осигурало правично коришћење серверских ресурса, MCP сервери могу имплементирати ограничење брзине за позиве алата и приступ ресурсима. Ограничења брзине могу се примењивати по кориснику, по сесији или глобално, и помажу у заштити од напада ускраћивања услуге или прекомерне потрошње ресурса.  

Комбинујући ове механизме, MCP пружа сигурну основу за интеграцију језичких модела са спољним алатима и изворима података, истовремено дајући корисницима и програмерима прецизну контролу над приступом и употребом.

## Поруке протокола и ток комуникације

MCP комуникација користи структуриране **JSON-RPC 2.0** поруке за олакшавање јасних и поузданих интеракција између хостова, клијената и сервера. Протокол дефинише специфичне обрасце порука за различите типове операција:

### Основни типови порука:

#### **Поруке иницијализације**
- **`initialize` Захтев**: Успоставља везу и преговара о верзији протокола и могућностима  
- **`initialize` Одговор**: Потврђује подржане функције и информације о серверу  
- **`notifications/initialized`**: Сигнализира да је иницијализација завршена и да је сесија спремна  

#### **Поруке откривања**
- **`tools/list` Захтев**: Открива доступне алате са сервера  
- **`resources/list` Захтев**: Листира доступне ресурсе (изворе података)  
- **`prompts/list` Захтев**: Преузима доступне шаблоне упита  

#### **Поруке извршења**  
- **`tools/call` Захтев**: Извршава одређени алат са датим параметрима  
- **`resources/read` Захтев**: Преузима садржај из одређеног ресурса  
- **`prompts/get` Захтев**: Преузима шаблон упита са опционим параметрима  

#### **Клијентске поруке**
- **`sampling/complete` Захтев**: Сервер захтева завршетак LLM-а од клијента  
- **`elicitation/request`**: Сервер захтева унос корисника преко клијентског интерфејса  
- **Поруке дневника**: Сервер шаље структуриране поруке у дневник клијенту  

#### **Поруке обавештења**
- **`notifications/tools/list_changed`**: Сервер обавештава клијента о променама алата  
- **`notifications/resources/list_changed`**: Сервер обавештава клијента о променама ресурса  
- **`notifications/prompts/list_changed`**: Сервер обавештава клијента о променама шаблона  

### Структура порука:

Све MCP поруке прате JSON-RPC 2.0 формат са:  
- **Захтевима**: Укључују `id`, `method` и опционе `params`  
- **Одговорима**: Укључују `id` и или `result` или `error`  
- **Обавештењима**: Укључују `method` и опционе `params` (без `id` или очекиваног одговора)  

Ова структурирана комуникација осигурава поуздане, пратљиве и прошириве интеракције које подржавају напредне сценарије као што су ажурирања у реалном времену, ланчање алата и робусно руковање грешкама.

## Кључне напомене

- **Архитектура**: MCP користи архитектуру клијент-сервер где хостови управљају више клијентских веза са серверима  
- **Учесници**: Екосистем укључује хостове (AI апликације), клијенте (конектори протокола) и сервере (пружаоце могућности)  
- **Транспортни механизми**: Комуникација подржава STDIO (локално) и стримујући HTTP са опционим SSE (удаљено)  
- **Основни примитиви**: Сервери излажу алате (извршиве функције), ресурсе (изворе података) и шаблоне (упите)  
- **Клијентски примитиви**: Сервери могу захтевати узорковање (LLM завршетке), тражење уноса (кориснички унос) и евидентирање од клијената  
- **Основе протокола**: Заснован на JSON-RPC 2.0 са верзионисањем заснованим на датуму (тренутно: 2025-06-18)  
- **Могућности у реалном времену**: Подржава обавештења за динамичка ажурирања и синхронизацију у реалном времену  
- **Безбедност на првом месту**: Изричита сагласност корисника, заштита приватности података и сигуран транспорт су основни захтеви  

## Вежба

Дизајнирајте једноставан MCP алат који би био користан у вашој области. Дефинишите:  
1. Како би се алат звао  
2. Које параметре би прихватао  
3. Какав излаз би враћао  
4. Како би модел могао да користи овај алат за решавање проблема корисника  

---

## Шта следи

Следеће: [Поглавље 2: Безбедност](../02-Security/README.md)  

**Одрицање од одговорности**:  
Овај документ је преведен коришћењем услуге за превођење помоћу вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако тежимо тачности, молимо вас да имате у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на изворном језику треба сматрати ауторитативним извором. За критичне информације препоручује се професионални превод од стране људи. Не сносимо одговорност за било каква неспоразумевања или погрешна тумачења настала услед коришћења овог превода.