<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "0a6a7bcb289c024a91289e0444cb370b",
  "translation_date": "2025-08-18T16:46:30+00:00",
  "source_file": "01-CoreConcepts/README.md",
  "language_code": "sr"
}
-->
# Основни концепти MCP: Савладавање Протокола Контекста Модела за интеграцију вештачке интелигенције

[![Основни концепти MCP](../../../translated_images/02.8203e26c6fb5a797f38a10012061013ec66c95bb3260f6c9cfd2bf74b00860e1.sr.png)](https://youtu.be/earDzWGtE84)

_(Кликните на слику изнад да бисте погледали видео лекцију)_

[Model Context Protocol (MCP)](https://gi- **Експлицитна сагласност корисника**: Сваки приступ подацима и операције захтевају експлицитно одобрење корисника пре извршења. Корисници морају јасно разумети који ће подаци бити приступачни и које ће радње бити извршене, уз детаљну контролу над дозволама и ауторизацијама.

- **Заштита приватности података**: Кориснички подаци се излажу само уз експлицитну сагласност и морају бити заштићени снажним контролама приступа током целог животног циклуса интеракције. Имплементације морају спречити неовлашћен пренос података и одржавати строге границе приватности.

- **Безбедност извршавања алата**: Свака активација алата захтева експлицитну сагласност корисника уз јасно разумевање функционалности алата, параметара и потенцијалног утицаја. Снажне безбедносне границе морају спречити ненамерно, небезбедно или злонамерно извршавање алата.

- **Сигурност транспортног слоја**: Сви комуникациони канали треба да користе одговарајуће механизме за шифровање и аутентификацију. Удаљене везе треба да имплементирају сигурне транспортне протоколе и правилно управљање акредитивима.

#### Смернице за имплементацију:

- **Управљање дозволама**: Имплементирајте систем дозвола са детаљном контролом који омогућава корисницима да одреде којим серверима, алатима и ресурсима се може приступити  
- **Аутентификација и ауторизација**: Користите сигурне методе аутентификације (OAuth, API кључеви) са правилним управљањем токенима и њиховим истеком  
- **Валидација уноса**: Проверавајте све параметре и уносе података у складу са дефинисаним шемама како бисте спречили нападе убацивањем  
- **Евидентирање активности**: Одржавајте свеобухватне записе свих операција ради праћења безбедности и усклађености  

[Model Context Protocol (MCP)](https://modelcontextprotocol.io/specification/2025-06-18/) је моћан, стандардизован оквир који оптимизује комуникацију између великих језичких модела (LLMs) и спољашњих алата, апликација и извора података. Овај водич ће вас провести кроз основне концепте MCP-а, осигуравајући да разумете његову клијент-сервер архитектуру, кључне компоненте, механизме комуникације и најбоље праксе имплементације.

## Преглед

Ова лекција истражује основну архитектуру и компоненте које чине MCP екосистем. Научићете о клијент-сервер архитектури, кључним компонентама и механизмима комуникације који покрећу MCP интеракције.

## Кључни циљеви учења

До краја ове лекције, моћи ћете да:

- Разумете MCP клијент-сервер архитектуру.  
- Идентификујете улоге и одговорности домаћина, клијената и сервера.  
- Анализирате основне карактеристике које чине MCP флексибилним слојем за интеграцију.  
- Научите како информације теку унутар MCP екосистема.  
- Стекнете практична знања кроз примере кода у .NET, Java, Python и JavaScript.  

## MCP архитектура: Детаљнији преглед

MCP екосистем је изграђен на клијент-сервер моделу. Ова модуларна структура омогућава AI апликацијама да ефикасно комуницирају са алатима, базама података, API-јевима и контекстуалним ресурсима. Хајде да разложимо ову архитектуру на њене основне компоненте.

У својој суштини, MCP прати клијент-сервер архитектуру где хост апликација може да се повеже са више сервера:

```mermaid
flowchart LR
    subgraph "Your Computer"
        Host["Host with MCP (Visual Studio, VS Code, IDEs, Tools)"]
        S1["MCP Server A"]
        S2["MCP Server B"]
        S3["MCP Server C"]
        Host <-->|"MCP Protocol"| S1
        Host <-->|"MCP Protocol"| S2
        Host <-->|"MCP Protocol"| S3
        S1 <--> D1[("Local\Data Source A")]
        S2 <--> D2[("Local\Data Source B")]
    end
    subgraph "Internet"
        S3 <-->|"Web APIs"| D3[("Remote\Services")]
    end
```

- **MCP домаћини**: Програми као што су VSCode, Claude Desktop, IDE-ови или AI алати који желе да приступе подацима преко MCP-а  
- **MCP клијенти**: Протокол клијенти који одржавају 1:1 везе са серверима  
- **MCP сервери**: Лагани програми који излажу специфичне могућности кроз стандардизован MCP протокол  
- **Локални извори података**: Фајлови, базе података и услуге на вашем рачунару којима MCP сервери могу безбедно приступити  
- **Удаљене услуге**: Спољашњи системи доступни преко интернета којима MCP сервери могу приступити преко API-ја.  

MCP протокол је еволутивни стандард који користи верзионисање засновано на датуму (формат YYYY-MM-DD). Тренутна верзија протокола је **2025-06-18**. Најновије ажуриране спецификације можете видети [овде](https://modelcontextprotocol.io/specification/2025-06-18/).

### 1. Домаћини

У Model Context Protocol (MCP), **домаћини** су AI апликације које служе као примарни интерфејс преко којег корисници комуницирају са протоколом. Домаћини координишу и управљају везама са више MCP сервера креирањем посебних MCP клијената за сваку серверску везу. Примери домаћина укључују:

- **AI апликације**: Claude Desktop, Visual Studio Code, Claude Code  
- **Развојна окружења**: IDE-ови и уређивачи кода са MCP интеграцијом  
- **Прилагођене апликације**: Специјализовани AI агенти и алати  

**Домаћини** су апликације које координишу интеракције са AI моделима. Они:

- **Организују AI моделе**: Извршавају или комуницирају са LLM-овима ради генерисања одговора и координације AI токова рада  
- **Управљају клијентским везама**: Креирају и одржавају MCP клијенте за сваку MCP серверску везу  
- **Контролишу кориснички интерфејс**: Управљају током разговора, интеракцијама са корисником и презентацијом одговора  
- **Спроводе безбедност**: Контролишу дозволе, безбедносна ограничења и аутентификацију  
- **Управљају сагласношћу корисника**: Обезбеђују одобрење корисника за дељење података и извршавање алата  

### 2. Клијенти

**Клијенти** су суштинске компоненте које одржавају посебне један-на-један везе између домаћина и MCP сервера. Сваки MCP клијент је инстанциран од стране домаћина ради повезивања са одређеним MCP сервером, осигуравајући организоване и безбедне комуникационе канале. Више клијената омогућава домаћинима да се истовремено повежу са више сервера.

**Клијенти** су конекторске компоненте унутар домаћинске апликације. Они:

- **Комуникација протокола**: Шаљу JSON-RPC 2.0 захтеве серверима са упутствима и промптовима  
- **Преговарање о могућностима**: Преговарају о подржаним функцијама и верзијама протокола са серверима током иницијализације  
- **Извршавање алата**: Управљају захтевима за извршавање алата од модела и обрађују одговоре  
- **Ажурирања у реалном времену**: Обрађују обавештења и ажурирања у реалном времену од сервера  
- **Обрада одговора**: Обрађују и форматирају одговоре сервера за приказ корисницима  

### 3. Сервери

**Сервери** су програми који пружају контекст, алате и могућности MCP клијентима. Они могу бити извршени локално (на истом рачунару као домаћин) или удаљено (на спољашњим платформама) и одговорни су за обраду захтева клијената и пружање структуираних одговора. Сервери излажу специфичну функционалност кроз стандардизован Model Context Protocol.

**Сервери** су услуге које пружају контекст и могућности. Они:

- **Регистрација функција**: Региструју и излажу доступне примитиве (ресурсе, промптове, алате) клијентима  
- **Обрада захтева**: Примају и извршавају позиве алата, захтеве за ресурсима и промптовима од клијената  
- **Пружање контекста**: Пружају контекстуалне информације и податке ради побољшања одговора модела  
- **Управљање стањем**: Одржавају стање сесије и обрађују интеракције са стањем када је потребно  
- **Обавештења у реалном времену**: Шаљу обавештења о променама могућности и ажурирањима повезаним клијентима  

Сервери могу бити развијени од стране било кога ради проширења могућности модела са специјализованом функционалношћу и подржавају како локалне тако и удаљене сценарије распоређивања.  

### 4. Примитиве сервера

Сервери у Model Context Protocol (MCP) пружају три основне **примитиве** које дефинишу основне грађевинске блокове за богате интеракције између клијената, домаћина и језичких модела. Ове примитиве одређују врсте контекстуалних информација и радњи доступних кроз протокол.

MCP сервери могу излагати било коју комбинацију следеће три основне примитиве:

#### Ресурси

**Ресурси** су извори података који пружају контекстуалне информације AI апликацијама. Они представљају статички или динамички садржај који може побољшати разумевање модела и доношење одлука:

- **Контекстуални подаци**: Структурисане информације и контекст за AI модел  
- **Базе знања**: Репозиторијуми докумената, чланци, приручници и истраживачки радови  
- **Локални извори података**: Фајлови, базе података и информације локалног система  
- **Спољашњи подаци**: Одговори API-ја, веб услуге и подаци удаљених система  
- **Динамички садржај**: Подаци у реалном времену који се ажурирају на основу спољашњих услова  

Ресурси се идентификују URI-јевима и подржавају откривање кроз методе `resources/list` и преузимање кроз `resources/read`:

```text
file://documents/project-spec.md
database://production/users/schema
api://weather/current
```

#### Промптови

**Промптови** су поново употребљиви шаблони који помажу у структуирању интеракција са језичким моделима. Они пружају стандардизоване обрасце интеракције и шаблоне токова рада:

- **Интеракције засноване на шаблонима**: Унапред структуиране поруке и почетни промптови за разговор  
- **Шаблони токова рада**: Стандардизовани низови за уобичајене задатке и интеракције  
- **Примери Few-shot**: Шаблони засновани на примерима за инструкције моделу  
- **Системски промптови**: Основни промптови који дефинишу понашање модела и контекст  
- **Динамички шаблони**: Параметризовани промптови који се прилагођавају специфичним контекстима  

Промптови подржавају замену променљивих и могу се открити преко `prompts/list` и преузети помоћу `prompts/get`:

```markdown
Generate a {{task_type}} for {{product}} targeting {{audience}} with the following requirements: {{requirements}}
```

#### Алати

**Алати** су извршиве функције које AI модели могу позвати ради извршавања специфичних радњи. Они представљају "глаголе" MCP екосистема, омогућавајући моделима да комуницирају са спољашњим системима:

- **Извршиве функције**: Дискретне операције које модели могу позвати са специфичним параметрима  
- **Интеграција спољашњих система**: API позиви, упити база података, операције са фајловима, прорачуни  
- **Јединствени идентитет**: Сваки алат има јединствено име, опис и шему параметара  
- **Структурисани улаз/излаз**: Алати прихватају валидиране параметре и враћају структурисане, типизиране одговоре  
- **Могућности радњи**: Омогућавају моделима да извршавају радње у стварном свету и добијају актуелне податке  

Алати су дефинисани JSON шемом за валидацију параметара и откривају се преко `tools/list`, а извршавају преко `tools/call`:

```typescript
server.tool(
  "search_products", 
  {
    query: z.string().describe("Search query for products"),
    category: z.string().optional().describe("Product category filter"),
    max_results: z.number().default(10).describe("Maximum results to return")
  }, 
  async (params) => {
    // Execute search and return structured results
    return await productService.search(params);
  }
);
```

## Примитиве клијената

У Model Context Protocol (MCP), **клијенти** могу излагати примитиве које омогућавају серверима да захтевају додатне могућности од домаћинске апликације. Ове примитиве на страни клијента омогућавају богатије, интерактивније имплементације сервера које могу приступити могућностима AI модела и интеракцијама са корисником.

### Узорковање

**Узорковање** омогућава серверима да захтевају комплетирање језичког модела од AI апликације клијента. Ова примитива омогућава серверима приступ LLM могућностима без уграђивања сопствених зависности модела:

- **Приступ независан од модела**: Сервери могу захтевати комплетирања без укључивања LLM SDK-ова или управљања приступом моделу  
- **AI иницијатива сервера**: Омогућава серверима да аутономно генеришу садржај користећи AI модел клијента  
- **Рекурзивне LLM интеракције**: Подржава сложене сценарије где серверима треба AI помоћ за обраду  
- **Генерисање динамичког садржаја**: Омогућава серверима да креирају контекстуалне одговоре користећи модел домаћина  

Узорковање се иницира преко методе `sampling/complete`, где сервери шаљу захтеве за комплетирање клијентима.

### Елицитација  

**Елицитација** омогућава серверима да захтевају додатне информације или потврду од корисника преко интерфејса клијента:

- **Захтеви за унос корисника**: Сервери могу тражити додатне информације када су потребне за извршавање алата  
- **Дијалози за потврду**: Захтевају одобрење корисника за осетљиве или
- **Управљање животним циклусом**: Обрађује иницијализацију везе, преговарање о могућностима и завршетак сесије између клијената и сервера  
- **Примитиви сервера**: Омогућава серверима да пружају основну функционалност кроз алате, ресурсе и шаблоне  
- **Примитиви клијента**: Омогућава серверима да захтевају узорковање од LLM-ова, прикупљају унос корисника и шаљу поруке дневника  
- **Обавештења у реалном времену**: Подржава асинхрона обавештења за динамичка ажурирања без потребе за честим проверама  

#### Кључне карактеристике:

- **Преговарање о верзији протокола**: Користи верзионисање засновано на датуму (ГГГГ-ММ-ДД) ради осигурања компатибилности  
- **Откривање могућности**: Клијенти и сервери размењују информације о подржаним функцијама током иницијализације  
- **Сесије са стањем**: Одржава стање везе током више интеракција ради континуитета контекста  

### Транспортни слој

**Транспортни слој** управља комуникационим каналима, обликовањем порука и аутентификацијом између MCP учесника:

#### Подржани транспортни механизми:

1. **STDIO транспорт**:  
   - Користи стандардне улазно/излазне токове за директну комуникацију процеса  
   - Оптималан за локалне процесе на истој машини без мрежног оптерећења  
   - Често се користи за локалне имплементације MCP сервера  

2. **Стримујући HTTP транспорт**:  
   - Користи HTTP POST за поруке од клијента ка серверу  
   - Опционо Server-Sent Events (SSE) за стримовање од сервера ка клијенту  
   - Омогућава комуникацију са удаљеним серверима преко мрежа  
   - Подржава стандардну HTTP аутентификацију (токени за приступ, API кључеви, прилагођени хедери)  
   - MCP препоручује OAuth за сигурну аутентификацију засновану на токенима  

#### Апстракција транспорта:

Транспортни слој апстрахује детаље комуникације од слоја података, омогућавајући исти формат порука JSON-RPC 2.0 за све транспортне механизме. Ова апстракција омогућава апликацијама да лако прелазе између локалних и удаљених сервера.

### Безбедносни аспекти

MCP имплементације морају поштовати неколико кључних безбедносних принципа како би осигурале сигурне, поуздане и безбедне интеракције у свим операцијама протокола:

- **Пристанак и контрола корисника**: Корисници морају дати изричит пристанак пре приступа подацима или извршавања операција. Требало би да имају јасну контролу над тим који подаци се деле и које акције су одобрене, уз подршку интуитивних интерфејса за преглед и одобравање активности.  

- **Приватност података**: Кориснички подаци могу бити изложени само уз изричит пристанак и морају бити заштићени одговарајућим контролама приступа. MCP имплементације морају спречити неовлашћен пренос података и осигурати да се приватност одржава током свих интеракција.  

- **Безбедност алата**: Пре позивања било ког алата, потребан је изричит пристанак корисника. Корисници треба да имају јасно разумевање функција сваког алата, а морају се спроводити робусне безбедносне границе како би се спречило ненамерно или небезбедно извршавање алата.  

Придржавањем ових безбедносних принципа, MCP осигурава да се поверење корисника, приватност и безбедност одржавају у свим интеракцијама протокола, истовремено омогућавајући моћне интеграције са вештачком интелигенцијом.

## Примери кода: Кључне компоненте

Испод су примери кода на неколико популарних програмских језика који илуструју како имплементирати кључне компоненте и алате MCP сервера.

### Пример за .NET: Креирање једноставног MCP сервера са алатима

Ово је практичан пример кода за .NET који демонстрира како имплементирати једноставан MCP сервер са прилагођеним алатима. Пример приказује како дефинисати и регистровати алате, обрађивати захтеве и повезати сервер користећи Model Context Protocol.

```csharp
using System;
using System.Threading.Tasks;
using ModelContextProtocol.Server;
using ModelContextProtocol.Server.Transport;
using ModelContextProtocol.Server.Tools;

public class WeatherServer
{
    public static async Task Main(string[] args)
    {
        // Create an MCP server
        var server = new McpServer(
            name: "Weather MCP Server",
            version: "1.0.0"
        );
        
        // Register our custom weather tool
        server.AddTool<string, WeatherData>("weatherTool", 
            description: "Gets current weather for a location",
            execute: async (location) => {
                // Call weather API (simplified)
                var weatherData = await GetWeatherDataAsync(location);
                return weatherData;
            });
        
        // Connect the server using stdio transport
        var transport = new StdioServerTransport();
        await server.ConnectAsync(transport);
        
        Console.WriteLine("Weather MCP Server started");
        
        // Keep the server running until process is terminated
        await Task.Delay(-1);
    }
    
    private static async Task<WeatherData> GetWeatherDataAsync(string location)
    {
        // This would normally call a weather API
        // Simplified for demonstration
        await Task.Delay(100); // Simulate API call
        return new WeatherData { 
            Temperature = 72.5,
            Conditions = "Sunny",
            Location = location
        };
    }
}

public class WeatherData
{
    public double Temperature { get; set; }
    public string Conditions { get; set; }
    public string Location { get; set; }
}
```

### Пример за Јаву: Компоненте MCP сервера

Овај пример демонстрира исти MCP сервер и регистрацију алата као горњи пример за .NET, али имплементиран у Јави.

```java
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpToolDefinition;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.server.tool.ToolExecutionContext;
import io.modelcontextprotocol.server.tool.ToolResponse;

public class WeatherMcpServer {
    public static void main(String[] args) throws Exception {
        // Create an MCP server
        McpServer server = McpServer.builder()
            .name("Weather MCP Server")
            .version("1.0.0")
            .build();
            
        // Register a weather tool
        server.registerTool(McpToolDefinition.builder("weatherTool")
            .description("Gets current weather for a location")
            .parameter("location", String.class)
            .execute((ToolExecutionContext ctx) -> {
                String location = ctx.getParameter("location", String.class);
                
                // Get weather data (simplified)
                WeatherData data = getWeatherData(location);
                
                // Return formatted response
                return ToolResponse.content(
                    String.format("Temperature: %.1f°F, Conditions: %s, Location: %s", 
                    data.getTemperature(), 
                    data.getConditions(), 
                    data.getLocation())
                );
            })
            .build());
        
        // Connect the server using stdio transport
        try (StdioServerTransport transport = new StdioServerTransport()) {
            server.connect(transport);
            System.out.println("Weather MCP Server started");
            // Keep server running until process is terminated
            Thread.currentThread().join();
        }
    }
    
    private static WeatherData getWeatherData(String location) {
        // Implementation would call a weather API
        // Simplified for example purposes
        return new WeatherData(72.5, "Sunny", location);
    }
}

class WeatherData {
    private double temperature;
    private String conditions;
    private String location;
    
    public WeatherData(double temperature, String conditions, String location) {
        this.temperature = temperature;
        this.conditions = conditions;
        this.location = location;
    }
    
    public double getTemperature() {
        return temperature;
    }
    
    public String getConditions() {
        return conditions;
    }
    
    public String getLocation() {
        return location;
    }
}
```

### Пример за Пајтон: Изградња MCP сервера

У овом примеру приказујемо како изградити MCP сервер у Пајтону. Такође су приказана два различита начина за креирање алата.

```python
#!/usr/bin/env python3
import asyncio
from mcp.server.fastmcp import FastMCP
from mcp.server.transports.stdio import serve_stdio

# Create a FastMCP server
mcp = FastMCP(
    name="Weather MCP Server",
    version="1.0.0"
)

@mcp.tool()
def get_weather(location: str) -> dict:
    """Gets current weather for a location."""
    # This would normally call a weather API
    # Simplified for demonstration
    return {
        "temperature": 72.5,
        "conditions": "Sunny",
        "location": location
    }

# Alternative approach using a class
class WeatherTools:
    @mcp.tool()
    def forecast(self, location: str, days: int = 1) -> dict:
        """Gets weather forecast for a location for the specified number of days."""
        # This would normally call a weather API forecast endpoint
        # Simplified for demonstration
        return {
            "location": location,
            "forecast": [
                {"day": i+1, "temperature": 70 + i, "conditions": "Partly Cloudy"}
                for i in range(days)
            ]
        }

# Instantiate the class to register its tools
weather_tools = WeatherTools()

# Start the server using stdio transport
if __name__ == "__main__":
    asyncio.run(serve_stdio(mcp))
```

### Пример за ЈаваСкрипт: Креирање MCP сервера

Овај пример приказује креирање MCP сервера у ЈаваСкрипту и како регистровати два алата повезана са временским условима.

```javascript
// Using the official Model Context Protocol SDK
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod"; // For parameter validation

// Create an MCP server
const server = new McpServer({
  name: "Weather MCP Server",
  version: "1.0.0"
});

// Define a weather tool
server.tool(
  "weatherTool",
  {
    location: z.string().describe("The location to get weather for")
  },
  async ({ location }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const weatherData = await getWeatherData(location);
    
    return {
      content: [
        { 
          type: "text", 
          text: `Temperature: ${weatherData.temperature}°F, Conditions: ${weatherData.conditions}, Location: ${weatherData.location}` 
        }
      ]
    };
  }
);

// Define a forecast tool
server.tool(
  "forecastTool",
  {
    location: z.string(),
    days: z.number().default(3).describe("Number of days for forecast")
  },
  async ({ location, days }) => {
    // This would normally call a weather API
    // Simplified for demonstration
    const forecast = await getForecastData(location, days);
    
    return {
      content: [
        { 
          type: "text", 
          text: `${days}-day forecast for ${location}: ${JSON.stringify(forecast)}` 
        }
      ]
    };
  }
);

// Helper functions
async function getWeatherData(location) {
  // Simulate API call
  return {
    temperature: 72.5,
    conditions: "Sunny",
    location: location
  };
}

async function getForecastData(location, days) {
  // Simulate API call
  return Array.from({ length: days }, (_, i) => ({
    day: i + 1,
    temperature: 70 + Math.floor(Math.random() * 10),
    conditions: i % 2 === 0 ? "Sunny" : "Partly Cloudy"
  }));
}

// Connect the server using stdio transport
const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

console.log("Weather MCP Server started");
```

Овај ЈаваСкрипт пример демонстрира како креирати MCP клијента који се повезује са сервером, шаље упит и обрађује одговор, укључујући све позиве алата који су извршени.

## Безбедност и ауторизација

MCP укључује неколико уграђених концепата и механизама за управљање безбедношћу и ауторизацијом током целог протокола:

1. **Контрола дозвола за алате**:  
   Клијенти могу одредити који алати су дозвољени моделу током сесије. Ово осигурава да су доступни само изричито одобрени алати, смањујући ризик од ненамерних или небезбедних операција. Дозволе се могу динамички конфигурисати на основу корисничких преференција, организационих политика или контекста интеракције.  

2. **Аутентификација**:  
   Сервери могу захтевати аутентификацију пре него што одобре приступ алатима, ресурсима или осетљивим операцијама. Ово може укључивати API кључеве, OAuth токене или друге шеме аутентификације. Правилна аутентификација осигурава да само поуздани клијенти и корисници могу позивати могућности сервера.  

3. **Валидација**:  
   Валидација параметара се спроводи за све позиве алата. Сваки алат дефинише очекиване типове, формате и ограничења за своје параметре, а сервер валидацију захтева обавља у складу с тим. Ово спречава да неисправан или злонамеран унос дође до имплементације алата и помаже у одржавању интегритета операција.  

4. **Ограничење брзине**:  
   Да би се спречила злоупотреба и осигурало правично коришћење серверских ресурса, MCP сервери могу имплементирати ограничење брзине за позиве алата и приступ ресурсима. Ограничења брзине могу се примењивати по кориснику, по сесији или глобално, и помажу у заштити од напада ускраћивања услуге или прекомерне потрошње ресурса.  

Комбинујући ове механизме, MCP пружа сигурну основу за интеграцију језичких модела са спољним алатима и изворима података, истовремено дајући корисницима и програмерима прецизну контролу над приступом и коришћењем.

## Поруке протокола и ток комуникације

MCP комуникација користи структуиране **JSON-RPC 2.0** поруке за олакшавање јасних и поузданих интеракција између хостова, клијената и сервера. Протокол дефинише специфичне обрасце порука за различите типове операција:

### Основни типови порука:

#### **Поруке иницијализације**
- **`initialize` Захтев**: Успоставља везу и преговара о верзији протокола и могућностима  
- **`initialize` Одговор**: Потврђује подржане функције и информације о серверу  
- **`notifications/initialized`**: Сигнализира да је иницијализација завршена и да је сесија спремна  

#### **Поруке откривања**
- **`tools/list` Захтев**: Открива доступне алате са сервера  
- **`resources/list` Захтев**: Листира доступне ресурсе (изворе података)  
- **`prompts/list` Захтев**: Преузима доступне шаблоне упита  

#### **Поруке извршења**  
- **`tools/call` Захтев**: Извршава одређени алат са датим параметрима  
- **`resources/read` Захтев**: Преузима садржај из одређеног ресурса  
- **`prompts/get` Захтев**: Преузима шаблон упита са опционим параметрима  

#### **Поруке са стране клијента**
- **`sampling/complete` Захтев**: Сервер захтева завршетак LLM-а од клијента  
- **`elicitation/request`**: Сервер захтева унос корисника преко интерфејса клијента  
- **Поруке дневника**: Сервер шаље структуиране поруке дневника клијенту  

#### **Поруке обавештења**
- **`notifications/tools/list_changed`**: Сервер обавештава клијента о променама алата  
- **`notifications/resources/list_changed`**: Сервер обавештава клијента о променама ресурса  
- **`notifications/prompts/list_changed`**: Сервер обавештава клијента о променама шаблона  

### Структура порука:

Све MCP поруке прате JSON-RPC 2.0 формат са:  
- **Захтевима**: Укључују `id`, `method` и опционе `params`  
- **Одговорима**: Укључују `id` и или `result` или `error`  
- **Обавештењима**: Укључују `method` и опционе `params` (без `id` или очекиваног одговора)  

Ова структуирана комуникација осигурава поуздане, пратљиве и прошириве интеракције које подржавају напредне сценарије као што су ажурирања у реалном времену, ланчање алата и робусно руковање грешкама.

## Кључни закључци

- **Архитектура**: MCP користи архитектуру клијент-сервер где хостови управљају више клијентских веза са серверима  
- **Учесници**: Екосистем укључује хостове (AI апликације), клијенте (конектори протокола) и сервере (пружаоце могућности)  
- **Транспортни механизми**: Комуникација подржава STDIO (локално) и стримујући HTTP са опционим SSE (удаљено)  
- **Основни примитиви**: Сервери излажу алате (извршиве функције), ресурсе (изворе података) и шаблоне (упите)  
- **Примитиви клијента**: Сервери могу захтевати узорковање (LLM завршетке), прикупљање уноса (кориснички унос) и евидентирање од клијената  
- **Основа протокола**: Заснован на JSON-RPC 2.0 са верзионисањем заснованим на датуму (тренутно: 2025-06-18)  
- **Могућности у реалном времену**: Подржава обавештења за динамичка ажурирања и синхронизацију у реалном времену  
- **Безбедност на првом месту**: Изричит пристанак корисника, заштита приватности података и сигуран транспорт су основни захтеви  

## Вежба

Дизајнирајте једноставан MCP алат који би био користан у вашој области. Дефинишите:  
1. Како би се алат звао  
2. Које параметре би прихватао  
3. Какав излаз би враћао  
4. Како би модел могао користити овај алат за решавање проблема корисника  

---

## Шта следи

Следеће: [Поглавље 2: Безбедност](../02-Security/README.md)  

**Одрицање од одговорности**:  
Овај документ је преведен коришћењем услуге за превођење помоћу вештачке интелигенције [Co-op Translator](https://github.com/Azure/co-op-translator). Иако настојимо да обезбедимо тачност, молимо вас да имате у виду да аутоматски преводи могу садржати грешке или нетачности. Оригинални документ на његовом изворном језику треба сматрати меродавним извором. За критичне информације препоручује се професионални превод од стране људи. Не преузимамо одговорност за било каква погрешна тумачења или неспоразуме који могу настати услед коришћења овог превода.